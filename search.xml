<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Controller日期格式转换</title>
    <url>/2020/05/03/Controller%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><ol><li>通过自定义时间格式，实现Controller对外统一时间类型的配置，通过这样的配置可以实现，所有进出Controller的时间格式均按照配置格式处理，不需要单独在LocalDateTime属性上增加格式化注解</li></ol><a id="more"></a><ol start="2"><li><p>相关常量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//年月正则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YYYYMM_REGEX = <span class="string">"^\\d&#123;4&#125;-\\d&#123;1,2&#125;$"</span>;</span><br><span class="line"><span class="comment">//年月日正则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YYYYMMDD_REGEX = <span class="string">"^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$"</span>;</span><br><span class="line"><span class="comment">//年月日时分正则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YYYYMMDDHHMM_REGEX = <span class="string">"^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$"</span>;</span><br><span class="line"><span class="comment">//年月日时分秒正则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YYYYMMDDHHMMSS_REGEX = <span class="string">"^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; &#123;1&#125;\\d&#123;1,2&#125;:\\d&#123;1,2&#125;:\\d&#123;1,2&#125;$"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------格式化相关常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_YYYY_MM_PATTERN = <span class="string">"yyyy-MM"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_YYYY_MM_DD_PATTERN = <span class="string">"yyyy-MM-dd"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_YYYY_MM_DD_HH_MM_PATTERN = <span class="string">"yyyy-MM-dd HH:mm"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_YYYY_MM_DD_HH_MM_SS_PATTERN = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_HH_MM_SS_PATTERN = <span class="string">"HH:mm:ss"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_HH_MM_SS_FORMATTER = DateTimeFormatter.ofPattern(NORMAL_HH_MM_SS_PATTERN);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_TIME_HH_MM_SS_FORMATTER = DateTimeFormatter.ofPattern(NORMAL_YYYY_MM_DD_HH_MM_SS_PATTERN);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_DEFAULT_FORMATTER = ISO_LOCAL_DATE;</span><br></pre></td></tr></table></figure></li><li><p>DateConverterConfig.java 时间转换配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverterConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LocalDate转换器，用于转换RequestParam和PathVariable参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Converter&lt;String, LocalDate&gt; <span class="title">localDateConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalDateConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LocalDateTime转换器，用于转换RequestParam和PathVariable参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Converter&lt;String, LocalDateTime&gt; <span class="title">localDateTimeConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalDateTimeConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LocalTime转换器，用于转换RequestParam和PathVariable参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Converter&lt;String, LocalTime&gt; <span class="title">localTimeConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalTimeConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Date转换器，用于转换RequestParam和PathVariable参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Converter&lt;String, Date&gt; <span class="title">dateConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DateConverter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化日期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dateStr String 字符型日期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format  String 格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Date 日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Date <span class="title">parseDate</span><span class="params">(String dateStr, String format)</span> <span class="keyword">throws</span> SystemException </span>&#123;</span><br><span class="line">        Date date;</span><br><span class="line">        DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(format);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = dateFormat.parse(dateStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            log.error(<span class="string">"&lt;&lt;&lt; date formatting exception msg: &#123;&#125;, e: &#123;&#125;"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="comment">// 自定义异常类</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(ResultEnum.SYSTEM_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtil.isBlank(source) || StringUtil.isBlank(source.trim())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (source.matches(YYYYMM_REGEX)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parseDate(source, NORMAL_YYYY_MM_PATTERN);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.matches(YYYYMMDD_REGEX)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parseDate(source, NORMAL_YYYY_MM_DD_PATTERN);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.matches(YYYYMMDDHHMM_REGEX)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parseDate(source, NORMAL_YYYY_MM_DD_HH_MM_PATTERN);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.matches(YYYYMMDDHHMMSS_REGEX)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parseDate(source, NORMAL_YYYY_MM_DD_HH_MM_SS_PATTERN);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid boolean value '"</span> + source + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SystemException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid boolean value '"</span> + source + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalTimeConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">LocalTime</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalTime <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtil.isBlank(source) || StringUtil.isBlank(source.trim())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LocalTime.parse(source, DATE_HH_MM_SS_FORMATTER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">LocalDateTime</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtil.isBlank(source) || StringUtil.isBlank(source.trim())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LocalDateTime.parse(source, DATE_TIME_HH_MM_SS_FORMATTER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LocalDate <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtil.isBlank(source) || StringUtil.isBlank(source.trim())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LocalDate.parse(source, DATE_DEFAULT_FORMATTER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ObjectMapper json序列化和反序列化配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line">    objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line">    objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line">    <span class="comment">// 设置全局的时间转化</span></span><br><span class="line">    SimpleDateFormat smt = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    objectMapper.setDateFormat(smt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//java8日期系列序列化和反序列化模块，继承自jsr310，我们在这里修改了日期格式</span></span><br><span class="line">    JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">    javaTimeModule.addSerializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeSerializer</span>(<span class="title">DATE_TIME_HH_MM_SS_FORMATTER</span>))</span>;</span><br><span class="line">    javaTimeModule.addSerializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateSerializer</span>(<span class="title">DATE_DEFAULT_FORMATTER</span>))</span>;</span><br><span class="line">    javaTimeModule.addSerializer(LocalTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalTimeSerializer</span>(<span class="title">DATE_HH_MM_SS_FORMATTER</span>))</span>;</span><br><span class="line">    javaTimeModule.addDeserializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeDeserializer</span>(<span class="title">DATE_TIME_HH_MM_SS_FORMATTER</span>))</span>;</span><br><span class="line">    javaTimeModule.addDeserializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateDeserializer</span>(<span class="title">DATE_DEFAULT_FORMATTER</span>))</span>;</span><br><span class="line">    javaTimeModule.addDeserializer(LocalTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalTimeDeserializer</span>(<span class="title">DATE_HH_MM_SS_FORMATTER</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Date序列化和反序列化</span></span><br><span class="line">    javaTimeModule.addSerializer(Date<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">DateSerializer</span>())</span>;</span><br><span class="line">    javaTimeModule.addDeserializer(Date<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">DateDeserializers</span>.<span class="title">DateDeserializer</span>())</span>;</span><br><span class="line"></span><br><span class="line">    objectMapper.registerModule(javaTimeModule);</span><br><span class="line">    <span class="keyword">return</span> objectMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Web MVC配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Converter dateConverter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Converter localTimeConverter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Converter localDateConverter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Converter localDateTimeConverter;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter(objectMapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addConverter(dateConverter);</span><br><span class="line">        registry.addConverter(localTimeConverter);</span><br><span class="line">        registry.addConverter(localDateConverter);</span><br><span class="line">        registry.addConverter(localDateTimeConverter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Class文件格式</title>
    <url>/2020/05/06/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>java是跨平台语言，跨平台的主要原因是因为java源文件编译成class文件后运行在JVM虚拟机上。JVM并不是跟java语言所绑定的，对于JVM来讲只要是符合规范的class文件都是可以执行的，正是因为这个原因现在出现了很多语言：Scala、Kotlin、Groovy、Jython、JRuby等等。这些语言都是运行JVM虚拟机上，所以我们还是需要了解class的文件结构。</p></blockquote><a id="more"></a><h3 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h3><ol><li><p>Class</p><blockquote><p>每个class文件都由字节流组成，每个字节含有8个二进制位所有16、32、64位长度的数据将通过2个、4个和8个连续的8位字节表示。</p></blockquote></li><li><p>无符号数</p><blockquote><p>用来描述数字、索引符号、数量值或者按照UTF-8编码格式的字符串。这些由一组数据类型来进行表示。他们由u1、u2、u4、u8分别表示1个字节、2个字节、4个字节和8个字节。</p></blockquote></li><li><p>ClassFile 结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4				magic; <span class="comment">// 魔数</span></span><br><span class="line">    u2				minor_version; <span class="comment">// 副版本号</span></span><br><span class="line">    u2				major_version; <span class="comment">// 主版本号</span></span><br><span class="line">    u2				constant_pool_count; <span class="comment">// 常量池数量</span></span><br><span class="line">    cp_info	       constant_poll[constant_pool_count-<span class="number">1</span>]; <span class="comment">// 常量池</span></span><br><span class="line">    u2				access_flags;</span><br><span class="line">    u2				this_class;</span><br><span class="line">    u2				super_class;</span><br><span class="line">    u2				interfaces_count; <span class="comment">// 接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>4.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列io之Base64</title>
    <url>/2018/07/28/Guava%E7%B3%BB%E5%88%97io%E4%B9%8BBase64/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><ul><li><p>Guava版本: 23.0</p></li><li><p>本章简单介绍一下BaseEncoding的编码以及反编码,该类可以使用base16(), base32(), base64()包括对URLbase64编码等等..这里简单的演示一下base64的编码及反编码.顺便解释一下base64的工作原理</p><a id="more"></a></li></ul><p>base64编码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase64Encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseEncoding baseEncoding = BaseEncoding.base64();</span><br><span class="line">    String encodeResult = baseEncoding.encode(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">    System.out.println(encodeResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/01.png" alt="01"></p><p>下面使用base64对aGVsbG8=进行解码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBase64Decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseEncoding baseEncoding = BaseEncoding.base64();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = baseEncoding.decode(<span class="string">"aGVsbG8="</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>很简单,结果就不展示了,就是上面的hello</p></li><li><p>base64是我们在平时的工作当中最常见的编码算法(这里指的是编码,不是加解密算法),URL base64编码,证书base64编码,包括公钥,私钥等等…那么为什么要使用base64进行编码呢? 大家都知道在对一串数据进行DES/DES3/AES加密完成之后,是一个byte数组,那么这个数组怎么保存到文本文件当中呢?这下就需要对这个数组使用base64编码之后才可以存到文本中.下面简单说一下base64编码的原理</p></li><li><p>大家都知道一个char是1byte,就是8bit.比如说一个字符<code>a</code>,那么<code>a</code>就是1byte –&gt; 8bit, 8bit 二进制 –&gt; 01100001, 那么base64呢不是根据8bit来算的, 是根据6bit来进行计算的, 比如上面01100001, 分成6bit就是011000 010000,后面4个0呢是补的, 也就是说如果不够6位, 那么就往后补0, 然后计算出这两个6位的十进制, 011000 –&gt;24, 010000 –&gt; 16.最后就是24 , 16. base64有一个编码表, 24是Y,16是Q. 前面补了4个0, 2个0是一个=号,4个0就是两个=号,那么最终的结果呢就是YQ==</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/02.png" alt="02"></p></li><li><p>知道了原理, 下面咱们自己手动实现一下base64 encoding,根据分析, 需要先定义一个编码字典.然后实现encode方法,首先判断入参是否为null, 接着将字符串先转换成二进制字符串, 将二进制分割成每6位一组,每6位转换成十进制, 十进制对应编码字典中的字符,最后补了几个0,就往后追加=号</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ENCODE_STRING = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码字典</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] ENCODE_DICT = ENCODE_STRING.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Base64</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Preconditions.checkNotNull(text);</span><br><span class="line">        <span class="comment">// 将文本转换成二进制字符串</span></span><br><span class="line">        String binaryStr = toBinary(text);</span><br><span class="line">        <span class="comment">// 每6位进行分割,不够6位追加0</span></span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">6</span> - binaryStr.length() % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (delta != <span class="number">6</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">                binaryStr += <span class="string">"0"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历二进制字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; binaryStr.length() / <span class="number">6</span>; index++) &#123;</span><br><span class="line">                <span class="comment">// 取出6位字符串</span></span><br><span class="line">                <span class="keyword">int</span> begin = index * <span class="number">6</span>;</span><br><span class="line">                String substr = binaryStr.substring(begin, begin + <span class="number">6</span>);</span><br><span class="line">                <span class="comment">// 将二进制字符串转换成十进制</span></span><br><span class="line">                Integer indexChar = Integer.valueOf(substr, <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 从字典中取出对应的字符</span></span><br><span class="line">                <span class="keyword">char</span> encodeChar = ENCODE_DICT[indexChar];</span><br><span class="line">                result.append(encodeChar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 追加的0, 每两个0追加为一个=号</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                result.append(<span class="string">"="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串转换成二进制字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toBinary</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder binaryResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; source.length(); index++) &#123;</span><br><span class="line">            <span class="keyword">final</span> StringBuilder binary = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> charAt = source.charAt(index);</span><br><span class="line">            <span class="comment">// 转换成二进制</span></span><br><span class="line">            String binaryStr = Integer.toBinaryString(charAt);</span><br><span class="line">            <span class="comment">// 追加补全8bit</span></span><br><span class="line">            <span class="keyword">int</span> delta = <span class="number">8</span> - binaryStr.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta; i++) &#123;</span><br><span class="line">                binary.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            binary.append(binaryStr);</span><br><span class="line">            binaryResult.append(binary);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binaryResult.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面测一下自己手写的base64编码算法,跟Guava提供的base64的算法是否一致</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyBase64Encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String myEncodeResult = Base64.encode(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    BaseEncoding baseEncoding = BaseEncoding.base64();</span><br><span class="line">    String encodeResult = baseEncoding.encode(<span class="string">"hello"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    assertThat(myEncodeResult, equalTo(encodeResult));</span><br><span class="line"></span><br><span class="line">    assertThat(Base64.encode(<span class="string">"wangzhi"</span>), equalTo(baseEncoding.encode(<span class="string">"wangzhi"</span>.getBytes())));</span><br><span class="line">    assertThat(Base64.encode(<span class="string">"JAVA"</span>), equalTo(baseEncoding.encode(<span class="string">"JAVA"</span>.getBytes())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面说一下base64的解码原理,解码整好是跟编码反过来,倒推一下. 编码是将字符弄成8位,然后6位. 解码是先6位,然后8位.比如说 YQ==, 首先看到有两个=号, 那么给=号干掉,然后剩余YQ,然后去编码字典中拿到YQ的下标(也就是十进制), 然后将十进制换成二进制,24 –&gt; 011000, 16 –&gt; 010000, 如果不够6位,就给前面补0.YQ的二进制就是011000 010000,因为后面的0是咱们补的,所以最后是011000010000 / 8, 也就是循环1次,然后每8位进行截取,拿到8位后的二进制之后转换成十进制,再将十进制找到对应的ASCII.01100001的十进制是97,转换成ASCII就是小写a.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/03.png" alt="03"></p><ul><li>下面看代码实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encrypt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(String encrypt)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(encrypt);</span><br><span class="line">    <span class="keyword">final</span> StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    String tmp = encrypt;</span><br><span class="line">    <span class="comment">// 判断是否包含=号, 去掉=号</span></span><br><span class="line">    <span class="keyword">int</span> index = tmp.indexOf(<span class="string">"="</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp.substring(<span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到转换后的二进制字符串</span></span><br><span class="line">    String binaryStr = toBase64Binary(tmp);</span><br><span class="line">    <span class="comment">// 每8位循环一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryStr.length() / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> begin = i * <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// 拿到8位二进制字符串</span></span><br><span class="line">        String substr = binaryStr.substring(begin, begin + <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 将二进制转换成十进制</span></span><br><span class="line">        Integer value = Integer.valueOf(substr, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 拿到十进制对应的ASCII</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = Character.toChars(value);</span><br><span class="line">        <span class="keyword">char</span> c = chars[<span class="number">0</span>];</span><br><span class="line">        result.append(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转换Base64Binary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toBase64Binary</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder binaryResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 循环编码字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.length(); i++) &#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 根据下标拿到编码字符</span></span><br><span class="line">        <span class="keyword">char</span> c = source.charAt(i);</span><br><span class="line">        <span class="comment">// 字符所在索引中的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = ENCODE_STRING.indexOf(c);</span><br><span class="line">        <span class="comment">// 将下标转换成二进制字符串</span></span><br><span class="line">        String binaryStr = Integer.toBinaryString(index);</span><br><span class="line">        <span class="comment">// 判断是否够6位, 不够往前补0</span></span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">6</span> - binaryStr.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; delta; j++) &#123;</span><br><span class="line">            builder.append(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(binaryStr);</span><br><span class="line">        binaryResult.append(builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryResult.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试一下</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(encode(<span class="string">"hello"</span>));</span><br><span class="line">    System.out.println(encode(<span class="string">"java"</span>));</span><br><span class="line">    System.out.println(encode(<span class="string">"scala"</span>));</span><br><span class="line">    System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(decode(<span class="string">"aGVsbG8="</span>));</span><br><span class="line">    System.out.println(decode(<span class="string">"amF2YQ=="</span>));</span><br><span class="line">    System.out.println(decode(<span class="string">"c2NhbGE="</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/04.png" alt="04"></p><p>项目地址:</p><p><a href="https://github.com/wz-dazhi/guavaNotes/blob/master/src/main/java/com/wz/guava/io/Base64.java" target="_blank" rel="noopener">https://github.com/wz-dazhi/guavaNotes/blob/master/src/main/java/com/wz/guava/io/Base64.java</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava io</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列io之字符(节)流</title>
    <url>/2018/07/25/Guava%E7%B3%BB%E5%88%97io%E4%B9%8B%E5%AD%97%E7%AC%A6-%E8%8A%82-%E6%B5%81/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><ul><li><p>Guava版本: 23.0</p></li><li><p>上节中简单介绍了Files的一些使用,通过Files可以很方便的对文件的一些操作.本节介绍一下<code>CharSource/CharSink</code> <code>ByteSource/ByteSink</code>, 前两个是对字符流的处理,相等于JDK中的<code>Reader/Writer</code>,Guava对其进行了封装. 后两个是对字节流的操作,当然也对应JDK中的<code>FileInputStream/FileOutputStream</code></p><a id="more"></a></li><li><p>在Files章节中已经演示过了对<code>CharSource/CharSink</code>字符的操作,通过Files.asCharSource()就可以拿到<code>CharSource</code>对象,Files.asCharSink()拿到<code>CharSink</code>对象.对字节的处理也是一样, Files.asByteSource(),Files.asByteSink(); 这里简单的讨论一下这四个类</p></li><li><p><code>CharSource</code>不止可以读取文件, 也可以将字符读到内存当中,然后处理.</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCharSource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CharSource charSource = CharSource.wrap(<span class="string">"i am the char source"</span>);</span><br><span class="line">    ImmutableList&lt;String&gt; lines = charSource.readLines();</span><br><span class="line">    assertThat(lines.get(<span class="number">0</span>), equalTo(<span class="string">"i am the char source"</span>));</span><br><span class="line">    assertThat(lines.size(), equalTo(<span class="number">1</span>));</span><br><span class="line">    String read = charSource.read();</span><br><span class="line">    assertThat(read, equalTo(<span class="string">"i am the char source"</span>));</span><br><span class="line">    <span class="keyword">boolean</span> empty = charSource.isEmpty();</span><br><span class="line">    assertThat(empty, equalTo(<span class="keyword">false</span>));</span><br><span class="line">    <span class="keyword">long</span> length = charSource.length();</span><br><span class="line">    assertThat(length, equalTo(<span class="number">20L</span>));</span><br><span class="line">    Optional&lt;Long&gt; longOptional = charSource.lengthIfKnown();</span><br><span class="line">    assertThat(longOptional.get(), equalTo(<span class="number">20L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还可以使用多个字符流进行操作,concat(..)方法可以传多个字符流.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 内部只使用一个字符流</span></span><br><span class="line">    CharSource charSource = CharSource.concat(</span><br><span class="line">            CharSource.wrap(<span class="string">"i am the char source1\n"</span>),</span><br><span class="line">            CharSource.wrap(<span class="string">"i am the char source2"</span>)</span><br><span class="line">    );</span><br><span class="line">    charSource.readLines().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>CharSink</code>在23.0版本中,并没有提供静态工厂方法可以获得对象, 但是可以使用Files.asCharSink()来获取,将字符串写到文件当中</li><li><code>ByteSource</code>跟<code>CharSource</code>是一样的,只是<code>ByteSource</code>是对字节的处理.读取字节文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByteSource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File sourceFile = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    ByteSource byteSource = Files.asByteSource(sourceFile);</span><br><span class="line">    <span class="keyword">byte</span>[] readResult = byteSource.read();</span><br><span class="line">    assertThat(readResult, equalTo(Files.toByteArray(sourceFile)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Files.asByteSource()拿到<code>ByteSource</code>对象.简单跟踪一下源码看是如何做到的,点击asByteSource()方法,进入方法内</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteSource <span class="title">asByteSource</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FileByteSource(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到是new 了一个文件字节流,这个是Guava提供的私有的静态内部类,点进去.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileByteSource</span> <span class="keyword">extends</span> <span class="title">ByteSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File file;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">FileByteSource</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.file = checkNotNull(file);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FileInputStream <span class="title">openStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查file是否为null,然后将file赋值给成员变量,可以看到它有一个openStream()方法,返回的是FileInputStream对象.当然该类还有几个方法,这里没列出来.返回我们的Junit 测试方法, 点击read()方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] read() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Closer closer = Closer.create();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream in = closer.register(openStream());</span><br><span class="line">    <span class="keyword">return</span> ByteStreams.toByteArray(in);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> closer.rethrow(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closer.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Closer对象注册了一个openStream()对象,其实就是将FileInputStream对象注册进去的,返回它的父类.点击ByteStreams.toByteArray(in);</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toByteArray(InputStream in) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Presize the ByteArrayOutputStream since we know how large it will need</span></span><br><span class="line">  <span class="comment">// to be, unless that value is less than the default ByteArrayOutputStream</span></span><br><span class="line">  <span class="comment">// size (32).</span></span><br><span class="line">  ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream(Math.max(<span class="number">32</span>, in.available()));</span><br><span class="line">  copy(in, out);</span><br><span class="line">  <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里可以看到自己new了一个输出流,经过copy方法后,out返回读取文件的二进制数据.再点击copy方法看看里面做了什么</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream from, OutputStream to)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotNull(from);</span><br><span class="line">  checkNotNull(to);</span><br><span class="line">  <span class="keyword">byte</span>[] buf = createBuffer();</span><br><span class="line">  <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> r = from.read(buf);</span><br><span class="line">    <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    to.write(buf, <span class="number">0</span>, r);</span><br><span class="line">    total += r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到先对input out校验,然后input读取字节,out将字节写入内存, 那么out对象当然就可以返回数据了</li><li>下面看一下<code>ByteSink</code>,将二进制写入文件中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testByteSink</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File targetPath = <span class="keyword">new</span> File(<span class="keyword">this</span>.targetPath);</span><br><span class="line">    targetPath.deleteOnExit();</span><br><span class="line">    ByteSink byteSink = Files.asByteSink(targetPath);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>&#125;;</span><br><span class="line">    byteSink.write(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字节文件, 对比数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes1 = Files.toByteArray(targetPath);</span><br><span class="line">    assertThat(bytes1, is(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>copy一个文件到另一个文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyByteFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File sourceFile = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    File targetFile = <span class="keyword">new</span> File(targetPath);</span><br><span class="line">    targetFile.deleteOnExit();</span><br><span class="line">    ByteSource byteSource = Files.asByteSource(sourceFile);</span><br><span class="line">    byteSource.copyTo(Files.asByteSink(targetFile));</span><br><span class="line"></span><br><span class="line">    HashCode hash1 = Files.asByteSource(sourceFile).hash(Hashing.sha256());</span><br><span class="line">    HashCode hash2 = Files.asByteSource(targetFile).hash(Hashing.sha256());</span><br><span class="line">    assertThat(hash1, equalTo(hash2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上就是对四个类简单的介绍下,顺便说了一个ByteSource的源码, Guava中的源码使用了大量的模式,而且不怎么难,通俗易懂,学习Guava源码也可以学到JDK中的源码.建议大家多学一下Guava中的源码思想</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava io</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列io之Files</title>
    <url>/2018/07/15/Guava%E7%B3%BB%E5%88%97io%E4%B9%8BFiles/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Guava版本: 23.0</p><p>本章主要介绍一下Guava的IO使用FIles对file的一些操作和使用方式</p><ul><li><p>首先定义两个文件,SOURCE_FILE是我提前新建好的,TARGET_FILE没有创建.使用Junit来操作这两个文件</p><a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SOURCE_FILE = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources/io/source.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String TARGET_FILE = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources/io/target.txt"</span>;</span><br></pre></td></tr></table></figure><ul><li>SOURCE_FILE文件中的内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/files-01.png" alt="01"></p><ul><li>使用Files复制SOURCE_FILE文件到TARGET_FILE,然后使用Files获取这两个文件的hash,以此来判断是否相等</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File targetFile = <span class="keyword">new</span> File(TARGET_FILE);</span><br><span class="line">    File sourceFile = <span class="keyword">new</span> File(SOURCE_FILE);</span><br><span class="line">    Files.copy(sourceFile, targetFile);</span><br><span class="line">    assertThat(targetFile.exists(), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 取两个文件的hash进行比较</span></span><br><span class="line">    HashCode sourceHashCode = Files.asByteSource(sourceFile).hash(Hashing.sha256());</span><br><span class="line">    HashCode targetHashCode = Files.asByteSource(targetFile).hash(Hashing.sha256());</span><br><span class="line">    assertThat(sourceHashCode, equalTo(targetHashCode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后使用Junit @After删除copy的文件.当然也可以直接在testCopyFile()方法中targetFile.deleteOnExit();这句话的意思就是说当程序运行完了之后会自动删除TARGET_FILE文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File targetFile = <span class="keyword">new</span> File(TARGET_FILE);</span><br><span class="line">    <span class="keyword">if</span> (targetFile.exists())</span><br><span class="line">        targetFile.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面使用的是Guava中的Files来copy文件, JDK中也有一个Files也可以copy文件,它是在<code>java.nio.file.Files</code>这个包下,这个属于JDK中nio2.0, Paths.get(“”)这个方法也可以直接将路径写完, 也可以使用下面这种方式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFileWithJDKNio2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    java.nio.file.Files.copy(</span><br><span class="line">            Paths.get(<span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources"</span>, <span class="string">"io"</span>, <span class="string">"source.txt"</span>),</span><br><span class="line">            Paths.get(<span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources"</span>, <span class="string">"io"</span>, <span class="string">"target.txt"</span>),</span><br><span class="line">            StandardCopyOption.REPLACE_EXISTING</span><br><span class="line">    );</span><br><span class="line">    File targetFile = <span class="keyword">new</span> File(TARGET_FILE);</span><br><span class="line">    assertThat(targetFile.exists(), equalTo(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动文件,或者重命名文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMoveFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Files.move(<span class="keyword">new</span> File(SOURCE_FILE), <span class="keyword">new</span> File(TARGET_FILE));</span><br><span class="line">        assertThat(<span class="keyword">new</span> File(TARGET_FILE).exists(), equalTo(<span class="keyword">true</span>));</span><br><span class="line">        assertThat(<span class="keyword">new</span> File(SOURCE_FILE).exists(), equalTo(<span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Files.move(<span class="keyword">new</span> File(TARGET_FILE), <span class="keyword">new</span> File(SOURCE_FILE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Files直接读取文件内容,接着使用Guava Joiner list字符串得到一个结果集,断言读取到的结果集是否跟定义的字符串相等</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String string = <span class="string">"hello guava.\n"</span> +</span><br><span class="line">            <span class="string">"this is txt files\n"</span> +</span><br><span class="line">            <span class="string">"\n"</span> +</span><br><span class="line">            <span class="string">"please see guava document or resource code"</span>;</span><br><span class="line">    <span class="comment">// 读取文件,设置字符集</span></span><br><span class="line">    List&lt;String&gt; strings = Files.readLines(<span class="keyword">new</span> File(SOURCE_FILE), Charsets.UTF_8);</span><br><span class="line">    String result = Joiner.on(<span class="string">"\n"</span>).join(strings);</span><br><span class="line">    assertThat(result, equalTo(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读取File并处理每一行的内容, 这里定义一个行处理器,处理器是一个泛型. 这里定义的是<code>List&lt;Integer&gt;</code>,当然处理后的结果集也是返回定义的泛型.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileProcess</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        Files.readLines(new File(SOURCE_FILE), Charsets.UTF_8, LineProcessor) // 过时</span></span><br><span class="line">        <span class="comment">// 定义行处理器</span></span><br><span class="line">        LineProcessor&lt;List&lt;Integer&gt;&gt; lineProcessor = <span class="keyword">new</span> LineProcessor&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> List&lt;Integer&gt; lengths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *[12, 17, 0, 42]</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 读文件的过程中, 处理读出来的行. 如果行的长度为0, 就不往后接着读了 --&gt; [12, 17]</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> line</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> length = line.length();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                lengths.add(length);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 返回处理后的结果</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> lengths;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Integer&gt; lengths = Files.asCharSource(<span class="keyword">new</span> File(SOURCE_FILE), Charsets.UTF_8).readLines(lineProcessor);</span><br><span class="line">        System.out.println(lengths);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>获取文件的hash值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算文件hash值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSha</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        HashCode hashCode = Files.hash(Hashing.goodFastHash(128)); // 过时</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(SOURCE_FILE);</span><br><span class="line">        HashCode hashCode = Files.asByteSource(file).hash(Hashing.sha256());</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>将字符串写入文件,这里写入了两次,第二次会覆盖之前写的内容</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入文件,写入多次会清空文件,然后写入新的内容(并不是append追加到该文件中)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String content1 = <span class="string">"content1"</span>;</span><br><span class="line">        String testFilePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources/io/test.txt"</span>;</span><br><span class="line">        File testFile = <span class="keyword">new</span> File(testFilePath);</span><br><span class="line">        testFile.deleteOnExit(); <span class="comment">// 表示程序结束后就删除文件</span></span><br><span class="line"><span class="comment">//        Files.write(content1,testFile, Charsets.UTF_8); // 过时</span></span><br><span class="line">        CharSink sink = Files.asCharSink(testFile, Charsets.UTF_8);</span><br><span class="line">        sink.write(content1);</span><br><span class="line">        <span class="comment">// 读出来进行断言</span></span><br><span class="line">        String readResult = Files.asCharSource(testFile, Charsets.UTF_8).read();</span><br><span class="line">        assertThat(content1, equalTo(readResult));</span><br><span class="line"></span><br><span class="line">        String content2 = <span class="string">"content2"</span>;</span><br><span class="line">        sink.write(content2);</span><br><span class="line">        readResult = Files.asCharSource(testFile, Charsets.UTF_8).read();</span><br><span class="line">        assertThat(content2, equalTo(readResult));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>追加内容到文件,这两个唯一的区别就在于Files.asCharSink()中的第三个参数,如果是覆盖内容,则不需要定义第三个参数,如果需要追加到文件,定义参数为FileWriteMode.APPEND,这是一个枚举类型的,在Guava 23.0这个版本中只有这一个枚举</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileAppend</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources/io/testAppend.txt"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    file.deleteOnExit();</span><br><span class="line">    CharSink sink = Files.asCharSink(file, Charsets.UTF_8, FileWriteMode.APPEND);</span><br><span class="line">    sink.write(<span class="string">"content 1"</span>);</span><br><span class="line">    CharSource charSource = Files.asCharSource(file, Charsets.UTF_8);</span><br><span class="line">    String result = charSource.read();</span><br><span class="line">    assertThat(result, equalTo(<span class="string">"content 1"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加</span></span><br><span class="line">    sink.write(<span class="string">"content 2"</span>);</span><br><span class="line">    result = charSource.read();</span><br><span class="line">    assertThat(result, equalTo(<span class="string">"content 1content 2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个空文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空的文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileTouch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src/test/resources/io/testTouch.txt"</span>;</span><br><span class="line">    File touchFile = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    touchFile.deleteOnExit();</span><br><span class="line">    Files.touch(touchFile);</span><br><span class="line">    assertThat(touchFile.exists(), equalTo(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自己手动写递归某文件夹下的所有文件夹及文件,或者只递归文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRecursive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src"</span>;</span><br><span class="line">    List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.recursive(<span class="keyword">new</span> File(filePath), files);</span><br><span class="line">    files.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己写递归遍历文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> files</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recursive</span><span class="params">(File file, List&lt;File&gt; files)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 文件夹,文件</span></span><br><span class="line">    <span class="comment">/*if (file.isHidden()) return;</span></span><br><span class="line"><span class="comment">    files.add(file);</span></span><br><span class="line"><span class="comment">    if (!file.isFile()) &#123;</span></span><br><span class="line"><span class="comment">        File[] listFiles = file.listFiles();</span></span><br><span class="line"><span class="comment">        for (File f : listFiles) &#123;</span></span><br><span class="line"><span class="comment">            recursive(f, files);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只拿文件</span></span><br><span class="line">    <span class="keyword">if</span> (file.isHidden()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">        files.add(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (File f : file.listFiles()) &#123;</span><br><span class="line">            recursive(f, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Files为我们提供的正序递归某文件夹下的所有文件夹以及文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilesPreOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src"</span>;</span><br><span class="line">    FluentIterable&lt;File&gt; files = Files.fileTreeTraverser().preOrderTraversal(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    files.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>倒序递归遍历文件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilesPostOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src"</span>;</span><br><span class="line">    FluentIterable&lt;File&gt; files = Files.fileTreeTraverser().postOrderTraversal(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    files.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按照目录阶梯式的递归遍历</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileBreadthFirstTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src"</span>;</span><br><span class="line">    FluentIterable&lt;File&gt; files = Files.fileTreeTraverser().breadthFirstTraversal(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    files.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只遍历子文件夹</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历文件夹中的子文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/Users/wangzhi/work/project/Guava/guava_programming/src"</span>;</span><br><span class="line">    Iterable&lt;File&gt; children = Files.fileTreeTraverser().children(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    children.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目地址:</p><p><a href="https://github.com/wz-dazhi/guavaNotes/blob/master/src/test/java/com/wz/guava/io/FilesTest.java" target="_blank" rel="noopener">https://github.com/wz-dazhi/guavaNotes/blob/master/src/test/java/com/wz/guava/io/FilesTest.java</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava io</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列utilities之Joiner</title>
    <url>/2018/07/04/Guava%E7%B3%BB%E5%88%97utilities%E4%B9%8BJoiner/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Guava版本: 23.0</p><p>本文使用Joiner做字符串的处理</p><ul><li><p>定义非null字符串集合, 带null字符串集合</p><a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义字符串集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; strings = Arrays.asList(<span class="string">"java"</span>, <span class="string">"guava"</span>, <span class="string">"google"</span>, <span class="string">"mysql"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义带null字符串集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; stringsWithNull = Arrays.asList(<span class="string">"oracle"</span>, <span class="string">"sql server"</span>, <span class="string">"db2"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><ul><li>进行字符串的拼接</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串拼接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String joinString = Joiner.on(<span class="string">"#"</span>).join(strings);</span><br><span class="line">    System.out.println(joinString);</span><br><span class="line">    assertThat(joinString, equalTo(<span class="string">"java#guava#google#mysql"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对带null的集合进行字符串拼接,<strong>注意:</strong> 会报空指针异常,所以这里在@Test上进行了处理</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带null字符串拼接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span>(expected = NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testJoinOnJoinWithNull</span>() </span>&#123;</span><br><span class="line">    String joinString = Joiner.on(<span class="string">"#"</span>).join(stringsWithNull);</span><br><span class="line">    System.out.println(joinString);</span><br><span class="line">    assertThat(joinString, equalTo(<span class="string">"oracle#sql server#db2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码会报空指针异常,现在使用Joiner拼接’#’字符串并且跳过null</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳过null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoinWithNullSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String joinString = Joiner.on(<span class="string">"#"</span>).skipNulls().join(stringsWithNull);</span><br><span class="line">    System.out.println(joinString);</span><br><span class="line">    assertThat(joinString, equalTo(<span class="string">"oracle#sql server#db2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然我们也可以使用jdk1.8的方式来实现上面功能</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用jdk1.8的方式拼接'#'字符串,并且跳过null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoiningByStreamSkipNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = stringsWithNull.stream().filter(s -&gt; s != <span class="keyword">null</span> &amp;&amp; !s.isEmpty()).collect(joining(<span class="string">"#"</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result, equalTo(<span class="string">"oracle#sql server#db2"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拼接’#’字符串,当碰到为null值的时候,赋默认值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为null值添加默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoinWithNullAddDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String defaultResultString = Joiner.on(<span class="string">"#"</span>).useForNull(<span class="string">"DEFAULT_VALUE"</span>).join(stringsWithNull);</span><br><span class="line">    System.out.println(defaultResultString);</span><br><span class="line">    assertThat(defaultResultString, equalTo(<span class="string">"oracle#sql server#db2#DEFAULT_VALUE"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>jdk1.8的实现方式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用jdk1.8的方式拼接'#'字符串,如果出现null,则给null添加默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoiningByStreamWithDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = stringsWithNull.stream().map(<span class="keyword">this</span>::defaultValue).collect(joining(<span class="string">"#"</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result, equalTo(<span class="string">"oracle#sql server#db2#DEFAULT_VALUE"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果为null或为"", 返回默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">defaultValue</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s == <span class="keyword">null</span> || s.isEmpty() ? <span class="string">"DEFAULT_VALUE"</span> : s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Joiner还可以进行appendTo操作,给Joiner传入一个builder,并且将原对象返回来,这里使用断言来判定是否属于同一个对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * appendTo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoinAppendTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder stringBuilder = Joiner.on(<span class="string">"#"</span>).useForNull(<span class="string">"DEFAULT_VALUE"</span>).appendTo(builder, stringsWithNull);</span><br><span class="line">    System.out.println(stringBuilder);</span><br><span class="line">    <span class="comment">// 断言是否同一个实例builder</span></span><br><span class="line">    assertThat(stringBuilder, sameInstance(builder));</span><br><span class="line">    assertThat(stringBuilder.toString(), equalTo(<span class="string">"oracle#sql server#db2#DEFAULT_VALUE"</span>));</span><br><span class="line">    assertThat(builder.toString(), equalTo(<span class="string">"oracle#sql server#db2#DEFAULT_VALUE"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还可以传入一个文件流,并且将拼接好的字符串写入到文件中,使用Guava的方式,观察以下代码,发现几行代码就搞定了.如果自己写呢???</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * stringList文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String targetFileName = <span class="string">"/Users/wangzhi/appedTo-writer.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * appendTo writer, 将追加的字符串写到文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoinAppendToWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(targetFileName))) &#123;</span><br><span class="line">        Joiner.on(<span class="string">"#"</span>).useForNull(<span class="string">"DEFAULT_VALUE"</span>).appendTo(writer, stringsWithNull);</span><br><span class="line">        <span class="comment">// 断言是否存在该文件</span></span><br><span class="line">        assertThat(Files.isFile().test(<span class="keyword">new</span> File(targetFileName)), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        fail(<span class="string">"append to the writer error..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Joiner操作map, 定义一个map</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义Map&lt;String, String&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; stringMap = of(<span class="string">"key1"</span>, <span class="string">"value1"</span>, <span class="string">"key2"</span>, <span class="string">"value2"</span>, <span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br></pre></td></tr></table></figure><ul><li>操作map</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作map, key=value拼接'#'字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoinMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String joinMap = Joiner.on(<span class="string">'#'</span>).withKeyValueSeparator(<span class="string">'='</span>).join(stringMap);</span><br><span class="line">    System.out.println(joinMap);</span><br><span class="line">    assertThat(joinMap, equalTo(<span class="string">"key1=value1#key2=value2#key3=value3"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将map拼接,并写到文件当中</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作map, key=value拼接'#'字符串, 并写入文件当中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJoinOnJoinAppendToMapWriter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileWriter writer = <span class="keyword">new</span> FileWriter(targetMapFileName)) &#123;</span><br><span class="line">        Joiner.on(<span class="string">'#'</span>).withKeyValueSeparator(<span class="string">'='</span>).appendTo(writer, stringMap);</span><br><span class="line">        assertThat(Files.isFile().test(<span class="keyword">new</span> File(targetMapFileName)), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        fail(<span class="string">"append to the stringMap writer..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上简单的介绍了一下Joiner的使用方式, 是不是比自己写优雅了很多,可以研究Google Guava的源码,学习一下大神的编程思想.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava utilities</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列utilities之Splitter</title>
    <url>/2018/07/05/Guava%E7%B3%BB%E5%88%97utilities%E4%B9%8BSplitter/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Guava版本: 23.0</p><p>本文使用Splitter做字符串的分割处理,Joiner主要是对字符串的拼接做处理,两者整好相反</p><ul><li><p>处理字符串分割,并返回list集合</p><a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割字符串,返回list集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = Splitter.on(<span class="string">"|"</span>).splitToList(<span class="string">"hello|world|java"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">3</span>));</span><br><span class="line">    assertThat(result.contains(<span class="string">"hello"</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    assertThat(result.contains(<span class="string">"world"</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分割字符串,并去除空串</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割字符串,并去除空串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnSplitOmitEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不去除空串</span></span><br><span class="line">    List&lt;String&gt; result = Splitter.on(<span class="string">"|"</span>).splitToList(<span class="string">"hello|world|java|||"</span>);</span><br><span class="line">    System.out.println(result); <span class="comment">// [hello, world, java, , , ]</span></span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除空串</span></span><br><span class="line">    result = Splitter.on(<span class="string">"|"</span>).omitEmptyStrings().splitToList(<span class="string">"hello|world|java|||"</span>);</span><br><span class="line">    System.out.println(result); <span class="comment">// [hello, world, java]</span></span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>去除空串并且去除空格</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去除字符串空格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnSplitTrim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除前</span></span><br><span class="line">    List&lt;String&gt; result = Splitter.on(<span class="string">"|"</span>).omitEmptyStrings().splitToList(<span class="string">"hello | world|java |||"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.get(<span class="number">0</span>), equalTo(<span class="string">"hello "</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">1</span>), equalTo(<span class="string">" world"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">2</span>), equalTo(<span class="string">"java "</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除后</span></span><br><span class="line">    result = Splitter.on(<span class="string">"|"</span>).omitEmptyStrings().trimResults().splitToList(<span class="string">"hello | world|java |||"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.get(<span class="number">0</span>), equalTo(<span class="string">"hello"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">1</span>), equalTo(<span class="string">"world"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">2</span>), equalTo(<span class="string">"java"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据长度对字符串进行分割</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据长度进行分割, 比如:每隔3个字符分割一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnFixedLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = Splitter.fixedLength(<span class="number">3</span>).splitToList(<span class="string">"123abcABC"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.get(<span class="number">0</span>), equalTo(<span class="string">"123"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">1</span>), equalTo(<span class="string">"abc"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">2</span>), equalTo(<span class="string">"ABC"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>limit的使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用limit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = Splitter.on(<span class="string">"|"</span>).limit(<span class="number">4</span>).splitToList(<span class="string">"hello|world|java|google|guava|scala"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">4</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">0</span>), equalTo(<span class="string">"hello"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">1</span>), equalTo(<span class="string">"world"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">2</span>), equalTo(<span class="string">"java"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">3</span>), equalTo(<span class="string">"google|guava|scala"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串正则表达式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用字符串正则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnPatternString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = Splitter.onPattern(<span class="string">"\\|"</span>).omitEmptyStrings().trimResults().splitToList(<span class="string">"hello | world||"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">2</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">0</span>), equalTo(<span class="string">"hello"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">1</span>), equalTo(<span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接使用正则表达式</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用正则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = Splitter.on(Pattern.compile(<span class="string">"\\|"</span>)).omitEmptyStrings().trimResults().splitToList(<span class="string">"hello | world||"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">2</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">0</span>), equalTo(<span class="string">"hello"</span>));</span><br><span class="line">    assertThat(result.get(<span class="number">1</span>), equalTo(<span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map的操作</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitOnSplitToMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; result = Splitter.on(<span class="string">'#'</span>).omitEmptyStrings().trimResults().withKeyValueSeparator(<span class="string">'='</span>).split(<span class="string">"hello=HELLO # world=WORLD#  ##"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    assertThat(result.size(), equalTo(<span class="number">2</span>));</span><br><span class="line">    assertThat(result.get(<span class="string">"hello"</span>), equalTo(<span class="string">"HELLO"</span>));</span><br><span class="line">    assertThat(result.get(<span class="string">"world"</span>), equalTo(<span class="string">"WORLD"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava utilities</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列io之Closer</title>
    <url>/2018/07/25/Guava%E7%B3%BB%E5%88%97io%E4%B9%8BCloser/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><ul><li><p>Guava版本: 23.0</p></li><li><p>在JDK7之前IO操作</p><a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    writer = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"/test.txt"</span>));</span><br><span class="line">    writer.write(<span class="string">"hello"</span>);</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码是JDK7之前的完整写法,创建对象,写入,刷新,关闭.看这一坨代码是否感觉头疼,当close的时候还需要捕获异常.JDK7出来了一种新的写法,那就是try-with-resources语句</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileWriter writer = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"/test.txt"</span>))) &#123;</span><br><span class="line">    writer.write(<span class="string">"hello"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基本的语法: try(…){}, try里面所有实现接口java.lang.AutoCloseable，包括java.io.Closeable的对象，在{}的语句块执行完毕后都会自动的close。</li><li>下面介绍一下Closer的用法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCloser</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Closer closer = Closer.create();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         InputStream inputStream = closer.register(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));</span><br><span class="line">         OutputStream outputStream = closer.register(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">""</span>)));</span><br><span class="line">         <span class="comment">// do stuff</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> closer.rethrow(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         closer.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到,首先创建了一个Closer对象,然后使用closer.register()注册了一个输入流和一个输出流.将IO对象交给Closer对象来管理.当catch异常的时候又做了一个throw closer.rethrow(e)操作, finally关闭流closer.close().在closer内部会挨个盘的关闭所有注册到Closer对象中的类,接着看一下在catch中的异常,为什么又抛出去了呢?下面重要讲解一下Closer的执行原理</li><li>首先看一下try catch的执行顺序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testTryCatchFinally</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; try..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"1"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; catch..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"2"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; finally..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单,这段Junit的执行顺序就是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">try</span>...</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">catch</span>...</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">finally</span>...</span><br></pre></td></tr></table></figure><p>下面再来一段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryCatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; try1..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try1"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; catch1..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"catch1"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// close();</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下, 上面代码中控制台会抛出哪个异常呢?看控制台</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/closer-01.png" alt="01"></p><p>有没有觉得惊讶?catch到了try中的RuntimeException,接着finally中假设调close()方法,又抛出了一个异常,但是我们预期抛的是catch中的异常,结果控制台并没有打印”catch1”,也就是没有抛出catch中的异常,而是只打印了finally中的RuntimeException”try2”.这就不对了,如果我们的操作在try中捕获到的异常,而控制台并没有输出,对于我们调试程序来说是比较困难的.如何将所有的异常都打印到控制台呢?看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryCatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; try1..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try1"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt; catch1..."</span>);</span><br><span class="line">        throwable = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// close();</span></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; try2..."</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try2"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; catch2..."</span>);</span><br><span class="line">            throwable.addSuppressed(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释上述代码,首先定义个最大的异常,接着catch到的异常赋值给throwable,接着throw e,在finally close()中,又将catch中的异常添加到throwable的异常栈中,addSuppressed(e)这个方法内部是一个list,泛型是Throwable,意思就是add异常的.在控制台中就会显示所有的异常信息,以便于我们调式问题</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/guava/closer-02.png" alt="02"></p><p>好,说了这么多,其实Closer也是这么做的,只是实现的方式不同.只要子类有实现Closerable接口,调用closer.register()方法后,Closer会将Closerable子类添加到一个双向队列中,当调用rethrow(e)方法, 也是跟咱们上面的catch语句中的写法一样,将抛出去的异常做一个记录,接着调用closer.close()方法后, 会挨着盘的调用Closerable子类的close()方法,如果抛出异常,使用反射机制invoke的调用Throwable中的<code>addSuppressed</code>方法,将所有抛出的异常反射添加到异常栈中.供我们调试程序.是不是很有用?有兴趣的朋友,可以学习一下Closer的源码(基本上都可以读懂),以及Guava设计的小技巧.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava io</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列utilities之Strings</title>
    <url>/2018/07/08/Guava%E7%B3%BB%E5%88%97utilities%E4%B9%8BStrings/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Guava版本: 23.0</p><p>在本章当中会简单的介绍一下Strings字符串的一些处理方式, 也是平时在开发过程中经常用到的.顺便也介绍一下CharMatcher的使用,这个类也是大多对于字符的一些匹配以及处理,由于CharMatcher类中的方法比较多, 这里只简单的列出一些.如果在开发过程中有过多的需求对字符的处理,可以查看CharMatcher的官方API</p><a id="more"></a><ul><li>Strings对字符串一些处理,Strings方法不是特别多,大概也就以下这些.</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对字符串的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空串变为null</span></span><br><span class="line">    <span class="keyword">final</span> String empty = Strings.emptyToNull(<span class="string">""</span>);</span><br><span class="line">    assertThat(empty, nullValue());</span><br><span class="line">    <span class="comment">// null变为空串</span></span><br><span class="line">    String nullResult = Strings.nullToEmpty(<span class="keyword">null</span>);</span><br><span class="line">    assertThat(nullResult, equalTo(<span class="string">""</span>));</span><br><span class="line">    <span class="comment">// 公共的前缀</span></span><br><span class="line">    String commonPrefix = Strings.commonPrefix(<span class="string">"hello world"</span>, <span class="string">"hi world"</span>);</span><br><span class="line">    assertThat(commonPrefix, equalTo(<span class="string">"h"</span>));</span><br><span class="line">    <span class="comment">// 公共的后缀</span></span><br><span class="line">    String commonSuffix = Strings.commonSuffix(<span class="string">"Guava"</span>, <span class="string">"Java"</span>);</span><br><span class="line">    assertThat(commonSuffix, equalTo(<span class="string">"ava"</span>));</span><br><span class="line">    <span class="comment">// 判断是否为null或者空串</span></span><br><span class="line">    <span class="keyword">boolean</span> nullOrEmpty = Strings.isNullOrEmpty(<span class="keyword">null</span>);</span><br><span class="line">    assertThat(nullOrEmpty, equalTo(<span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 向前缀填充字符, 设置最小字符串长度, 如果超过长度,则不进行填充. 示列:minLength为4 ava -&gt; java, minLength为5 ava -&gt; jjava</span></span><br><span class="line">    String padStart = Strings.padStart(<span class="string">"ava"</span>, <span class="number">4</span>, <span class="string">'j'</span>);</span><br><span class="line">    assertThat(padStart, equalTo(<span class="string">"java"</span>));</span><br><span class="line">    <span class="comment">// 向后缀进行填充, 与padStart相反</span></span><br><span class="line">    String padEnd = Strings.padEnd(<span class="string">"Guav"</span>, <span class="number">5</span>, <span class="string">'a'</span>);</span><br><span class="line">    assertThat(padEnd, equalTo(<span class="string">"Guava"</span>));</span><br><span class="line">    <span class="comment">// 重复字符串</span></span><br><span class="line">    String repeat = Strings.repeat(<span class="string">"java"</span>, <span class="number">3</span>);</span><br><span class="line">    assertThat(repeat, equalTo(<span class="string">"javajavajava"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符的匹配处理</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCharMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是数字</span></span><br><span class="line">    assertThat(CharMatcher.digit().matches(<span class="string">'5'</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    assertThat(CharMatcher.digit().matches(<span class="string">'a'</span>), equalTo(<span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 所有是否是数字</span></span><br><span class="line">    assertThat(CharMatcher.digit().matchesAllOf(<span class="string">"123"</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 是否存在数字</span></span><br><span class="line">    assertThat(CharMatcher.digit().matchesAnyOf(<span class="string">"hello 12 world"</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 是否不存在数字</span></span><br><span class="line">    assertThat(CharMatcher.digit().matchesNoneOf(<span class="string">"hello"</span>), equalTo(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符出现的次数</span></span><br><span class="line">    assertThat(CharMatcher.is(<span class="string">'a'</span>).countIn(<span class="string">"java"</span>), equalTo(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 找到匹配字符串的索引</span></span><br><span class="line">    assertThat(CharMatcher.is(<span class="string">'a'</span>).indexIn(<span class="string">"Guava"</span>), equalTo(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 从自定位置开始查找字符所在字符串中的索引</span></span><br><span class="line">    assertThat(CharMatcher.is(<span class="string">'o'</span>).indexIn(<span class="string">"hello"</span>, <span class="number">2</span>), equalTo(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类方法挺多的,这里就不再一一演示了...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然Guava也提供了字符集的类,这里简单的写一下Charsets, 这个类的字符集都是些静态常量.这里简单调一下,并和Charset进行比较</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">    assertThat(charset, equalTo(Charsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava utilities</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava系列utilities之Preconditions</title>
    <url>/2018/07/08/Guava%E7%B3%BB%E5%88%97utilities%E4%B9%8BPreconditions/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Guava版本: 23.0</p><p>本章使用Guava中的Preconditionds进行断言检查,并自定义一些我们所期望的异常信息</p><ul><li><p>检查不能为null, 这里使用expected指定会抛出我们期望的异常</p><a id="more"></a></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查不能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span>(expected = NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testCheckNotNull</span>() </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    Preconditions.checkNotNull(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查不能为null,并且自定义我们期望的异常信息.这里使用<code>try catch</code>的方式进行捕获一下,并打印一下我们自定义的异常信息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查不能为null,并自定义错误信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckNotNullWithMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(list, <span class="string">"the list not null"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        assertTrue(e <span class="keyword">instanceof</span> NullPointerException);</span><br><span class="line">        assertThat(e.getMessage(), equalTo(<span class="string">"the list not null"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查不能为null,并且自定义一个能够格式化的异常信息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查不能为null,自定义格式化异常信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckNotNullWithFormatMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(list, <span class="string">"the list -&gt; %s %s"</span>, <span class="string">"not"</span>, <span class="string">"null"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        assertTrue(e <span class="keyword">instanceof</span> NullPointerException);</span><br><span class="line">        assertThat(e.getMessage(), equalTo(<span class="string">"the list -&gt; not null"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用Java8中Objects来判断不能为null</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Java8中Objects判断不能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span>(expected = NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testObjectsNotNull</span>()</span>&#123;</span><br><span class="line">    String string = <span class="keyword">null</span>;</span><br><span class="line">    Objects.requireNonNull(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查我们所期望的状态信息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String state = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkState(<span class="string">"B"</span>.equals(state), <span class="string">"the state is illegal.."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        assertTrue(e <span class="keyword">instanceof</span> IllegalStateException);</span><br><span class="line">        assertThat(e.getMessage(), equalTo(<span class="string">"the state is illegal.."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查我们传递的参数是否是期望的值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckArguments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(<span class="string">"world"</span>.equals(str));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        assertTrue(e <span class="keyword">instanceof</span> IllegalArgumentException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查参数,并且自定义异常信息. (跟检查null自定义异常信息是一样的)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查参数,并自定义异常消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckArgumentsWithMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(<span class="string">"world"</span>.equals(str), <span class="string">"the str is illegal.."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        assertTrue(e <span class="keyword">instanceof</span> IllegalArgumentException);</span><br><span class="line">        assertThat(e.getMessage(), equalTo(<span class="string">"the str is illegal.."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查集合下标是否越界, 这里也是使用Guava集合中的Immutable.of()方法, 这样做的意义就是避免集合为null,当我们调用list.size()方法的时候,不至于出现空指针异常</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查集合下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCheckListIsIndexOutOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; list = ImmutableList.of();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Preconditions.checkElementIndex(<span class="number">10</span>, list.size());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        assertTrue(e <span class="keyword">instanceof</span> IndexOutOfBoundsException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用断言的方式检查是否为null, expected指定我们期望的异常</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用断言的方式检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span>(expected = AssertionError<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testAssert</span>() </span>&#123;</span><br><span class="line">    List&lt;Object&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> list != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>断案检查, 并自定义异常信息</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断言判断,自定义异常信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAssertWithMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> list != <span class="keyword">null</span> : <span class="string">"the list not null"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error error) &#123;</span><br><span class="line">        System.out.println(error.getMessage());</span><br><span class="line">        assertTrue(error <span class="keyword">instanceof</span> AssertionError);</span><br><span class="line">        assertThat(error.getMessage(), equalTo(<span class="string">"the list not null"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava utilities</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Centos6.5安装JDK以及环境变量的配置</title>
    <url>/2018/06/10/Linux-Centos6-5%E5%AE%89%E8%A3%85JDK%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a><strong>前言:</strong></h5><ul><li>操作系统: Linux CentOS6.5</li><li>JDK: 1.8</li></ul><h5 id="查看并卸载CentOS自带的OpenJDK"><a href="#查看并卸载CentOS自带的OpenJDK" class="headerlink" title="查看并卸载CentOS自带的OpenJDK"></a><strong>查看并卸载CentOS自带的OpenJDK</strong></h5><ul><li><p><strong>注意:</strong> 一般云服务器是不存在OpenJDK的,所以可以直接跳过第一步,直接进行第二步.(目前笔者没有碰到过阿里云,腾讯云服务器上存在OpenJDK)</p><a id="more"></a></li><li><p>安装好的CentOS会自带OpenJdk,使用命令 <code>java -version</code>，会有下面的信息：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># java -version  </span></span><br><span class="line">java version <span class="string">"1.6.0"</span>  </span><br><span class="line">OpenJDK Runtime Environment (build <span class="number">1.6</span>.<span class="number">0</span><span class="literal">-b09</span>)  </span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM (build <span class="number">1.6</span>.<span class="number">0</span><span class="literal">-b09</span>, mixed mode)</span><br></pre></td></tr></table></figure></li><li><p>最好还是先卸载掉openjdk,在安装sun公司的jdk.先使用查看命令 <code>rpm -qa | grep java</code>,显示如下信息:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># rpm -qa | grep java</span></span><br><span class="line">java<span class="literal">-1</span>.<span class="number">4.2</span><span class="literal">-gcj</span><span class="literal">-compat</span><span class="literal">-1</span>.<span class="number">4.2</span>.<span class="number">0</span><span class="literal">-40jpp</span>.<span class="number">115</span>  </span><br><span class="line">java<span class="literal">-1</span>.<span class="number">6.0</span><span class="literal">-openjdk</span><span class="literal">-1</span>.<span class="number">6.0</span>.<span class="number">0</span><span class="literal">-1</span>.<span class="number">7</span>.b09.el5</span><br></pre></td></tr></table></figure></li><li><p>卸载:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># rpm -e --nodeps java-1.4.2-gcj-compat-1.4.2.0-40jpp.115  </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5</span></span><br></pre></td></tr></table></figure></li><li><p>还有一些其他的命令:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># rpm -qa | grep gcj  </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># rpm -qa | grep jdk</span></span><br></pre></td></tr></table></figure></li><li><p>如果出现找不到openjdk source的话，那么还可以这样卸载:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-40jpp.115  </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># yum -y remove java java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a><strong>下载安装</strong></h5><ul><li><p>首先到官网下载jdk,官网地址:<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>. 根据机器需要的版本下载,这里下载jdk-8u151-linux-x64.tar.gz</p></li><li><p>登录终端,在/usr/local/目录下创建文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ2zecynwitmm44le6sjb9Z ~]# cd /usr/local/</span><br><span class="line">[root@iZ2zecynwitmm44le6sjb9Z local]# mkdir java</span><br></pre></td></tr></table></figure></li><li><p>使用ftp工具将下载好的压缩包上传到/usr/local/java/ 目录下</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-jdk-01.png" alt="01"></p></li><li><p>解压压缩包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ2zecynwitmm44le6sjb9Z java]# tar -zxvf jdk-8u151-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-jdk-02.png" alt="02"></p></li><li><p>然后可以删除压缩包了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ2zecynwitmm44le6sjb9Z java]# rm -rf jdk-8u151-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a><strong>设置环境变量</strong></h5><ul><li><p>进入jdk1.8.0_151目录下, 使用<code>pwd</code>命令查看当前所在目录, 并复制目录/usr/local/java/jdk1.8.0_151</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">jdk1.8.0_151</span>]<span class="comment"># pwd</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-jdk-03.png" alt="03"></p></li><li><p>全局设置jdk环境变量，就是修改/etc/profile，它是是所有用户的共用的环境变量 . 使用<code>vi /etc/profile</code>命令打开文件</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">jdk1.8.0_151</span>]<span class="comment"># vi /etc/profile</span></span><br></pre></td></tr></table></figure></li><li><p>将光标移动到文件末尾,然后按键盘<code>a</code>键进行编辑profile文件,将以下配置复制到profile文件末尾. <strong>注意:</strong> JAVA_HOME=/usr/local/java/jdk1.8.0_151(是刚刚复制的目录)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.<span class="number">8.0</span>_151  </span><br><span class="line">export CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar  </span><br><span class="line">export PATH=<span class="variable">$PATH:</span><span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure></li><li><p>然后按Esc键, 输入<code>:x</code>保存文件并退出, 接着执行生效命令,使环境变量立即生效.生效命令如下:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">jdk1.8.0_151</span>]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure></li><li><p>检查JAVA环境变量更改是否生效 , 当出现以下版本号,表示JDK环境变量配置成功,JDK也安装完毕</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ2zecynwitmm44le6sjb9Z jdk1.8.0_151]# java -version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-jdk-04.png" alt="04"></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Centos6.5安装redis</title>
    <url>/2018/06/10/Linux-Centos6-5%E5%AE%89%E8%A3%85redis/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a><strong>前言:</strong></h5><ul><li><p>操作系统: Linux CentOS6.5</p></li><li><p>redis: 4.0.9</p><a id="more"></a></li></ul><h5 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a><strong>下载解压</strong></h5><ul><li><p>登录终端,在/usr/local/目录下创建redis文件夹</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># cd /usr/local/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">local</span>]<span class="comment"># mkdir redis</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>cd redis</code>命令进入redis目录下,接着下载redis4.0.9</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">local</span>]<span class="comment"># cd redis</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>]<span class="comment"># wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-redis4-01.png" alt="1528560811908"></p></li><li><p>敲回车键进行下载,下完后. 发现当前目录下有一个<code>redis-4.0.9.tar.gz</code>的压缩包</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-redis4-02.png" alt="02"></p></li><li><p>解压压缩包</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>]<span class="comment"># tar xzf redis-4.0.9.tar.gz</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-redis4-03.png" alt="03"></p></li></ul><h5 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a><strong>编译安装</strong></h5><ul><li><p>进入redis-4.0.9目录下, 进行编译安装</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>]<span class="comment"># cd redis-4.0.9</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>-<span class="number">4.0</span><span class="type">.9</span>]<span class="comment"># make</span></span><br></pre></td></tr></table></figure></li><li><p>稍等一会, 编译完成后二进制文件在src目录下</p></li></ul><h5 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a><strong>启动redis</strong></h5><ul><li><p>启动redis.</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>-<span class="number">4.0</span><span class="type">.9</span>]<span class="comment"># ./src/redis-server</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-redis4-04.png" alt="04"></p></li><li><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>-<span class="number">4.0</span><span class="type">.9</span>]<span class="comment"># ./src/redis-server redis.conf</span></span><br></pre></td></tr></table></figure></li><li><p>加上<code>&amp;</code>号启动redis,可以使redis以后台的程序方式运行</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用默认配置后台启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>-<span class="number">4.0</span><span class="type">.9</span>]<span class="comment"># ./src/redis-server &amp; </span></span><br><span class="line"><span class="comment"># 使用默认配置文件的方式后台启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>-<span class="number">4.0</span><span class="type">.9</span>]<span class="comment"># ./src/redis-server redis.conf &amp;</span></span><br></pre></td></tr></table></figure></li><li><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。再启动一个终端,使用内置的客户端命令redis-cli进行使用测试,同样进入/usr/local/redis/redis-4.0.9目录下,然后启动客户端. 出现下图表明客户端连接成功.</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> ~]<span class="comment"># cd /usr/local/redis/redis-4.0.9</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iZ2zecynwitmm44le6sjb9Z</span> <span class="type">redis</span>-<span class="number">4.0</span><span class="type">.9</span>]<span class="comment"># ./src/redis-cli</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-redis4-05.png" alt="05"></p></li><li><p>客户端测试</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">"bar"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-6-soft-redis4-06.png" alt="06"></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装JDK1.8</title>
    <url>/2018/07/01/Mac%E5%AE%89%E8%A3%85JDK1-8/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>Mac系统版本：10.13.5</p><p>JDK：1.8</p><a id="more"></a><h5 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h5><ul><li><p>JDK官网下载地址：<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p></li><li><p>时间长了，上面的网址可能会发生变动，这个地址会列出所有版本</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-01.png" alt="01"></p></li><li><p>这里点击Java SE 8下载链接</p></li><li><p>选择同意，第一个单选按钮，接着点解Mac OS X x64后面的下载链接</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-02.png" alt="02"></p></li><li><p>下载完成后，得到一个dmg安装包，双击安装包</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-03.png" alt="03"></p></li><li><p>接着双击中间的pkg文件，按照提示开始安装</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-04.png" alt="04"></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-05.png" alt="05"></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-06.png" alt="06"></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-07.png" alt="07"></p></li></ul><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><ul><li><p>首先找到JDK安装的目录, 一般都在资源库目录下完整目录为：/资源库/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-08.png" alt="08"></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-09.png" alt="09"></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-10.png" alt="10"></p></li><li><p>打开terminal终端, 通过以下命令启动.bash_profile文件,修改内容</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">sudo vi .bash_profile</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-11.png" alt="11"></p></li><li><p>打开文件后,按键盘a或者i键进行编辑文件,添加以下内容.</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.<span class="number">8.0</span>_162.jdk/Contents/Home</span><br><span class="line">export PATH=<span class="variable">$PATH:</span><span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure></li><li><p>再按ESC, 输入<code>:x</code> 进行保存退出</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-12.png" alt="12"></p></li><li><p>在终端输入java -version验证</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mac/mac-soft-jdk8-13.png" alt="13"></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac OS软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL驱动升级到8.0.15之后产生的时区问题</title>
    <url>/2020/01/04/MySQL%E9%A9%B1%E5%8A%A8%E5%8D%87%E7%BA%A7%E5%88%B08-0-15%E4%B9%8B%E5%90%8E%E4%BA%A7%E7%94%9F%E7%9A%84%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><p><strong>MySQL驱动升级到8.0出现的时区问题</strong></p><ul><li><p>复现如下</p><a id="more"></a></li></ul><ol><li>xml 配置</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数据库表, 其中createTime 字段为默认值(根据当前时间插入)</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test_date`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`testDate`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`testDateTime`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`createTime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'测试时间表'</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>java 代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Date testDate;</span><br><span class="line">    <span class="keyword">private</span> Date testDateTime;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestDateMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"INSERT INTO test_date(testDate, testDateTime) VALUES (#&#123;testDate&#125; ,#&#123;testDateTime&#125; )"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(TestDate record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis config sample --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"UNPOOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"temp"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.rnjf.bj.dao.temp.TestDateMapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>junit 测试</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDateMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestDateMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpMybatisDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory builder = new SqlSessionFactoryBuilder().build(TestDateMapperTest.class.getClassLoader().getResourceAsStream("mybatisTestConfiguration/TestDateMapperTestConfiguration.xml"));</span><br><span class="line">        mapper = builder.getConfiguration().getMapper(TestDateMapper<span class="class">.<span class="keyword">class</span>, <span class="title">builder</span>.<span class="title">openSession</span>(<span class="title">true</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        TestDate testDate = TestDate.builder().testDate(date).testDateTime(date).build();</span><br><span class="line">        mapper.insert(testDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>查看数据库表数据<br><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mysql/mysql-driver-01.png" alt="01.png"></li></ol><p><strong>可以看到createTime是当前时间, testDate 少了1天, testDateTime 少了13个小时. 这是因为MySQL驱动升级后<code>serverTimezone</code> 属性默认为UTC</strong></p><ul><li>解决时区问题</li></ul><ol><li>URL后面加上<code>serverTimezone</code>参数, 将值设置为上海时区</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>继续单元测试, 测试结果如下<br><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/mysql/mysql-driver-02.png" alt="02.png"></li></ol><p><strong>总结:</strong></p><ul><li>这是因为mysql驱动升级到8.0之后发生了变化, 细心的读者可能看到驱动Driver类也发生了变化. 之前使用的是<code>com.mysql.jdbc.Driver</code>. 而现在使用的<code>com.mysql.cj.jdbc.Driver</code></li><li>如果加上这个也没能解决时区的问题, 第一看下MySQL服务器的时区是否存在问题. 第二看下MySQL自身的时区.</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>MySQL问题</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Centos7安装redis</title>
    <url>/2019/09/15/Linux-Centos7%E5%AE%89%E8%A3%85redis/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a><strong>前言:</strong></h5><ul><li><p>操作系统: Linux CentOS7.6.1810</p></li><li><p>redis: 5.0.5 -&gt; redis 官网: <a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><a id="more"></a></li></ul><h5 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹</span></span><br><span class="line">mkdir -p /usr/local/redis5</span><br><span class="line">cd /usr/local/redis5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载wget命令</span></span><br><span class="line">yum install -y wget</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载redis...tar.gz</span></span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压文件夹</span></span><br><span class="line">tar xf redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure><h5 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入解压后的目录下</span></span><br><span class="line">cd redis-5.0.5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将源码编译成可执行程序. 这个时候在src目录下就可以看到可执行的程序, 就可以使用./redis-server来启动redis服务了. 但是为了方便我们不可能每次都要这样来启动, 所以请往下看.</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> make的过程中报 /bin/sh: cc: <span class="built_in">command</span> not found, 这是因为redis是c语言写的,缺少gcc编译包. 安装gcc即可</span></span><br><span class="line">yum install -y gcc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续进行make 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候又报错: zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除一下上次的编译即可</span></span><br><span class="line">make distclean</span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续make, 这个时候会提示Hint: It<span class="string">'s a good idea to run '</span>make <span class="built_in">test</span><span class="string">' ;)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以运行 make <span class="built_in">test</span> 进行测试一下.有兴趣的同学可以自行运行. </span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装redis, 并指定安装位置(会自动创建目录)</span></span><br><span class="line">make install PREFIX=/opt/soft/redis5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录可以看到该目录下有一个bin目录, 进入bin目录可以看到源码目录中src目录下的可执行文件已经安装到这个目录下</span></span><br><span class="line">cd /opt/soft/redis5</span><br><span class="line">cd bin</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-7-soft-redis5-01.png" alt="01"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这个时候就安装好了. 可以执行./redis-server来运行了. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来将redis安装成本地服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将这个目录配置成环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 光标移动到最下面按字母 i或a 写入以下</span></span><br><span class="line">export REDIS_HOME=/opt/soft/redis5</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 写完后按 esc键, 输入 :x 保存退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使环境立即生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候回到源码目录下</span></span><br><span class="line">cd /usr/local/redis5/redis-5.0.5/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入utils目录下</span></span><br><span class="line">cd utils/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候可以看到一个 install_server.sh  安装服务的sh 脚本, 执行该脚本</span></span><br><span class="line">./install_server.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个时候提示设置启动端口(不填默认6379)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接着会显示6379的配置文件(不填默认 /etc/redis/6379.conf)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接着显示6379的<span class="built_in">log</span>文件(不填默认 /var/<span class="built_in">log</span>/redis_6379.log)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接着显示6379的data文件(不填默认 /var/lib/redis/6379)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接着显示6379的执行程序(不填默认 /opt/soft/redis5/bin/redis-server, 因为配置环境变量所以会自动找到)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后会展示一下选择后的列表, 按回车确认 或 按 Ctrl-C 撤回, 这里按回车</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回车后会看到安装服务, 添加启动自启, 并运行该服务</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-7-soft-redis5-02.png" alt="02"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装服务后都会在 /etc/init.d/目录下, 所以在/etc/init.d/目录下可以看到一个redis_6379的服务文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务状态. </span></span><br><span class="line">service redis_6379 status</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-7-soft-redis5-03.png" alt="03"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一个程序是可以在系统中存在多个进程的, 所以这里在 utils目录下再装一个6380端口的redis服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里继续执行./install_server.sh, 不过只改一个端口</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-7-soft-redis5-04.png" alt="04"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行ps -ef|grep redis就可以看到启动了两个redis服务</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/centos/c-7-soft-redis5-05.png" alt="05"></p><h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><p>这里简单介绍一下redis的编译,安装, 以及将redis做成本地服务.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>java Class加载过程</title>
    <url>/2020/03/29/java-Class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><blockquote><p>一个java源文件编译成二进制.class文件，.class文件被JVM加载到内存开始。它的整个生命周期分为：加载、验证、准备、解析、初始化、使用、卸载。</p><p>其中类加载过程分为3个阶段：加载、链接、初始化</p></blockquote><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328230118098.png" alt="类加载7部曲"></p><h3 id="Loading-加载"><a href="#Loading-加载" class="headerlink" title="Loading 加载"></a>Loading 加载</h3><ol><li>类加载是第一阶段，当<code>new Object()</code>的时候。会根据全限定类名将.class二进制文件加载到内存中。</li><li>加载到内存中的字节流存储转化为方法区的运行时数据结构。</li><li>类加载的过程是一个繁琐且复杂的过程，采用的是双亲委派模型。在上一篇文章中详细的讲解了一个类加载到内存中的详细过程。Java中的类加载器是如何实现的，自定义类加载器，以及如何打破双亲委派机制。[点击了解双亲委派机制](<a href="https://hexo.dazhi.info/2020/03/28/java" target="_blank" rel="noopener">https://hexo.dazhi.info/2020/03/28/java</a> 双亲委派机制.html#more)</li><li>加载完成之后会在java堆中生成一个这个Class的对象，作为方法区中的数据访问入口。这个加载过程主要是靠类加载来完成的，当然我们也可以自定义类加载器来做一些定制化实现。</li></ol><h3 id="Linking-链接"><a href="#Linking-链接" class="headerlink" title="Linking 链接"></a>Linking 链接</h3><ol><li><p>Verification 验证</p><p>校验Class文件格式，校验的目的是为了确保Class文件中的二进制数据流是否符合当前虚拟机的要求，并且不会危害虚拟机本身的安全。</p></li><li><p>Preparation 准备</p><p>将类的静态变量赋予默认值，初始值是在类进行初始化的时候赋予初始值。</p></li><li><p>Resolution 解析</p><p>解析主要就是<strong>将常量池中的符号引用替换为直接引用</strong>的过程。<code>符号引用</code>就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析。</p></li></ol><h3 id="Initializing-初始化"><a href="#Initializing-初始化" class="headerlink" title="Initializing 初始化"></a>Initializing 初始化</h3><ol><li>按照类静态变量、静态语句块顺序执行。</li><li>静态变量赋予初始值。</li><li>执行静态语句块。</li><li>JVM规范严格规定了有且只有五种情况会对类进行初始化<ul><li>使用new getstatic putstatic invokestatic指令，final除外（final修饰的会在编译的时候就会确定，编译器做了优化）。</li><li>使用java.lang.reflect对类进行反射调用的时候。</li><li>初始化子类的时候，必须先初始化父类。</li><li>虚拟机启动的时候，必须初始化一个带main方法的主类。</li><li>使用动态语言支持，一个java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化。</li></ul></li></ol><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><blockquote><ol><li>new对象的过程，如果该类是第一次实例化的。（执行上面过程）</li><li>首先会将该类的.class 文件load到内存，然后校验文件格式、元数据、字节码、符号引用，接着准备为类静态变量赋予默认值，将符号引用转换为直接引用，最后进行初始化过程。</li><li>为对象申请内存，成员变量赋予默认值，调用构造方法<init><ul><li>调用super()父类构造方法，如果父类没有初始化，必须先初始化父类。</li><li>成员变量顺序赋予初始值</li><li>执行构造方法内语句</li></ul></init></li></ol></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式之责任链(ChainOfResponsibility)</title>
    <url>/2018/07/16/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE-ChainOfResponsibility/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>今天学习一下责任链模式,顾名思义这个模式就跟链条一样,一条接着一条.这里使用一个简单的例子来分析一下责任链模式,接着模拟一下JavaEE中的Filter</p><a id="more"></a><ul><li>首先创建一个客户端,这里起名叫Main,这个客户端是发送一条消息,我们的任务呢是处理这条信息,大家都知道在网页中<code>&lt;script&gt;</code>这个标签呢属于前端脚本,我们就处理消息中是否存在HTML标签, 是否存在一些敏感的字眼(防止被和谐掉).为了简单起见,所以这里创建一个消息的处理类,起名MsgProcessor</li></ul><p>Main.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">"hello :), &lt;script&gt;alert('hello')&lt;/script&gt;敏感信息,被就业...测试信息"</span>;</span><br><span class="line">        MsgProcessor mp = <span class="keyword">new</span> MsgProcessor();</span><br><span class="line">        mp.setMsg(msg);</span><br><span class="line">        String result = mp.process();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MsgProcessor.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String r = msg;</span><br><span class="line">        <span class="comment">// 处理HTML</span></span><br><span class="line">        r = r.replace(<span class="string">'&lt;'</span>, <span class="string">'['</span>).replace(<span class="string">'&gt;'</span>, <span class="string">']'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理敏感字眼</span></span><br><span class="line">        r = r.replace(<span class="string">"敏感"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被就业,改为就业</span></span><br><span class="line">        r = r.replace(<span class="string">"被就业"</span>, <span class="string">"就业"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般如果将这些信息发送到服务端,服务端会处理这些信息.这里MsgProcessor将&lt;括号替换为[, 将&gt;括号替换为],将敏感字眼替换为””. 运行如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello :), [script]alert(<span class="string">'hello'</span>)[/script]信息,就业...测试信息</span><br></pre></td></tr></table></figure><p>可以看到我们的消息处理类已经成功了处理了客户端发送的消息,如果说我们需要将<code>:)</code>这个符号换成一个小笑脸,该怎么办呢?有人说简单,直接在MsgProcessor process方法中再加一条就可以了.那如果说还想处理一些其他的信息.该怎么办呢?既然处理消息的方法是动态改变的,那么我们是不是可以进行封装一下呢?这里呢我们可以创建一个接口,起名叫Filter,只要实现了这个Filter都可以对这个消息进行处理.为了简单起见里面只有一个doFilter方法,返回值为处理后String</p><p>Filter.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">doFilter</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然处理HTML标签,那么我们可以创建一个HTMLFilter实现Filter接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doFilter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理HTML</span></span><br><span class="line">        <span class="keyword">return</span> msg.replace(<span class="string">'&lt;'</span>, <span class="string">'['</span>).replace(<span class="string">'&gt;'</span>, <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有处理敏感字眼的Filter</p><p>SensitiveFilter.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doFilter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理敏感字眼</span></span><br><span class="line">        <span class="keyword">return</span> msg.replace(<span class="string">"敏感"</span>, <span class="string">""</span>).replace(<span class="string">"被就业"</span>, <span class="string">"就业"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就需要修改一下MsgProcessor, 增加Filter成员变量,里面存储一系列的Filter,然后修改process方法,循环所有的Filter,调用doFilter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Filter[] filters = &#123;<span class="keyword">new</span> HTMLFilter(),<span class="keyword">new</span> SensitiveFilter()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String r = msg;</span><br><span class="line">    <span class="keyword">for</span> (Filter f : filters) &#123;</span><br><span class="line">        r = f.doFilter(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话, 我们如果想要加别的Filter,只要实现Filter接口,定义自己的过滤规则,将规则实现类添加到Filter数组里就可以了.也就是说当一条消息来的时候,先进行HTMLFilter处理,再接着SensitiveFilter处理,这一条消息经过一系列的过滤才能达到下一个目的地,就形成了一个链条,这就是Chain Of Responsibility(责任链)</p><p>当然,这只是简单责任链.那么我们考虑一个问题,前面我们有两个Filter形成了一个链条,如果我们想在这个两个Filter中间加入一个或多个Filter,也可以理解成在这两个Filter中间加入一个链条或多个链条,<strong><em>注意:</em></strong> 这里的链条是指一个或多个Filter形成的链条. 并且可以任意组合,这个时候我们该怎么设计呢?</p><p>一般情况下,我们会定义一个类,这个类在JavaEE中是一个接口,这里为了简单,创建一个类(而不是接口).这个类里面装着一系列的Filter,我叫他FilterChain,并且让它实现Filter接口,里面定义一个addFilter方法,可以装Filter,当然也可以装FilterChain,因为FilterChain也实现了Filter接口,这里为了方便,addFilter方法返回this,意思是可以一直调用addFilter方法,这种是链式编程</p><p>FilterChain.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doFilter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Filter f : filters) &#123;</span><br><span class="line">            msg = f.doFilter(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改MsgProcessor.Java,我们把FilterChain作为消息处理器的成员变量,并调用doFilter方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private Filter[] filters = &#123;new HTMLFilter(),new SensitiveFilter()&#125;;</span></span><br><span class="line">    <span class="keyword">private</span> FilterChain fc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fc.doFilter(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略get set...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看我们的Main客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">"hello :), &lt;script&gt;alert('hello')&lt;/script&gt;敏感信息,被就业...测试信息"</span>;</span><br><span class="line">        MsgProcessor mp = <span class="keyword">new</span> MsgProcessor();</span><br><span class="line">        mp.setMsg(msg);</span><br><span class="line">        <span class="comment">// 定义FilterChain</span></span><br><span class="line">        FilterChain chain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        chain.addFilter(<span class="keyword">new</span> HTMLFilter())</span><br><span class="line">             .addFilter(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line"></span><br><span class="line">        mp.setFc(chain);</span><br><span class="line">        String result = mp.process();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们是不是就可以加入另一个链条呢?为了演示,重新定义个小笑脸的FaceFilter,并创建另一个FilterChain,将FaceFilter加入到FilterChain2中</p><p>FaceFilter.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doFilter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg.replace(<span class="string">":)"</span>, <span class="string">"^V^"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">"hello :), &lt;script&gt;alert('hello')&lt;/script&gt;敏感信息,被就业...测试信息"</span>;</span><br><span class="line">        MsgProcessor mp = <span class="keyword">new</span> MsgProcessor();</span><br><span class="line">        mp.setMsg(msg);</span><br><span class="line">        <span class="comment">// 定义FilterChain</span></span><br><span class="line">        FilterChain chain1 = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        chain1.addFilter(<span class="keyword">new</span> HTMLFilter())</span><br><span class="line">             .addFilter(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义第二个FilterChain</span></span><br><span class="line">        FilterChain chain2 = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        chain2.addFilter(<span class="keyword">new</span> FaceFilter());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第二个FilterChain放到第一个FilterChain中</span></span><br><span class="line">        chain1.addFilter(chain2);</span><br><span class="line"></span><br><span class="line">        mp.setFc(chain1);</span><br><span class="line">        String result = mp.process();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如下(可以看到我们将<code>:)</code>替换成了<code>^V^</code>):</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/cor-01.png" alt="01"></p><p>好,现在看一下消息的处理过程,这里简单画一个图</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/cor-02.png" alt="02"></p><p>现在呢我们已经实现了客户端发送的消息,并进行一系列的消息处理器.但是现在呢是单向的,也就是处理的过程中一直向前进行处理.现在我们考虑一个问题,如果处理消息的过程中,我既想让他发送的处理, 也想让他返回的时候进行处理.什么意思呢?一起看一下图:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/cor-03.png" alt="03"></p><p>如果大家学过JavaEE中Filter,相信这个图大家都应该明白我的意思,这很明显就是客户端发送一个请求,经过一系列的过滤器,然后处理请求,接着再响应一系列的过滤器,最后响应给客户消息.那么这个时候又该怎么办呢?这里为了模拟JavaEE中的Filter,我重新创建一个工程,我叫它JavaWEBFilter,拷贝一下工程,稍微修改一下代码.既然是为了模拟JavaEE,那么肯定有请求,也有响应,那么这里创建两个类,一个叫Request,另一个叫Response.为了简单起见,这两个类只封装一个String的成员变量,当然真正的Request,Response封装的东西挺多的!我们先一起来看代码,后面我们解释执行的原理</p><p>Request.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Response.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Filter类,将我们的Request和Response,还有FilterChain放入doFilter方法中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req, Response resp, FilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilterChain修改如下,这里使用一个计数器来记录执行到哪一个Filter了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req, Response resp, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == filters.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Filter filter = <span class="keyword">this</span>.filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(req, resp, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTMLFilter.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req, Response resp, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理HTML</span></span><br><span class="line">        String reqResult = req.getValue().replace(<span class="string">'&lt;'</span>, <span class="string">'['</span>).replace(<span class="string">'&gt;'</span>, <span class="string">']'</span>) + <span class="string">"---HTMLFilter()---"</span>;</span><br><span class="line">        req.setValue(reqResult);</span><br><span class="line"></span><br><span class="line">        chain.doFilter(req, resp, chain);</span><br><span class="line"></span><br><span class="line">        String respResult = resp.getValue() + <span class="string">"---HTMLFilter()---"</span>;</span><br><span class="line">        resp.setValue(respResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SensitiveFilter.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req, Response resp, FilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理敏感字眼</span></span><br><span class="line">        String reqResult = req.getValue().replace(<span class="string">"敏感"</span>, <span class="string">""</span>).replace(<span class="string">"被就业"</span>, <span class="string">"就业"</span>) + <span class="string">"---SensitiveFilter()---"</span>;</span><br><span class="line">        req.setValue(reqResult);</span><br><span class="line"></span><br><span class="line">        chain.doFilter(req, resp, chain);</span><br><span class="line"></span><br><span class="line">        String respResult = resp.getValue() + <span class="string">"---SensitiveFilter()---"</span>;</span><br><span class="line">        resp.setValue(respResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">"hello :), &lt;script&gt;alert('hello')&lt;/script&gt;敏感信息,被就业...测试信息"</span>;</span><br><span class="line">        Request req = <span class="keyword">new</span> Request();</span><br><span class="line">        req.setValue(msg);</span><br><span class="line">        Response resp = <span class="keyword">new</span> Response();</span><br><span class="line">        resp.setValue(<span class="string">"&gt;&gt;&gt; response--"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义FilterChain</span></span><br><span class="line">        FilterChain chain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        chain.addFilter(<span class="keyword">new</span> HTMLFilter())</span><br><span class="line">             .addFilter(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line"></span><br><span class="line">        chain.doFilter(req, resp, chain);</span><br><span class="line"></span><br><span class="line">        System.out.println(req.getValue());</span><br><span class="line">        System.out.println(resp.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了简单起见呢只处理Request, Response简单设置一个字符串.下面我们一起来梳理一下执行原理:</p><ul><li>首先在客户端我们定义了一个msg,将msg赋值给Request,Response简单设了一个值.然后将HTMLFilter,SensitiveFilter add到FilterChain里,最后调用FilterChain中的doFilter</li><li>在FilterChain的doFilter方法中我们记录一个当前执行到哪一个Filter的下标,目前是第0个,也就是HTMLFilter,接着调用HTMLFilter中的doFilter</li><li>在HTMLFilter的doFilter方法中开始处理Request请求,处理完了之后接着调用FilterChain中的doFilter</li><li>此时FilterChain中的doFilter开始执行第1个Filter,也就是SensitiveFilter中的doFilter</li><li>SensitiveFilter的doFilter接着处理Request,处理完消息之后接着调用FilterChain中的doFilter</li><li>此时FilterChain中的index为2,filters.size()也为2. 那么开始在FilterChain方法中返回</li><li>首先返回到SensitiveFilter中的doFilter,然后处理Response,接着返回到FilterChain,FilterChain返回到HTMLFilter的doFilter,接着处理Response,处理Response之后又返回给FilterChain,此时,我们在Main客户端FilterChain中的doFilter方法才执行完毕.这里简单打印了一下Request,Response中的value值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/cor-04.png" alt="04"></p><p>上图打印的结果可以看到HTMLFilter先进行处理Request, 然后SensitiveFilter处理Request. 接着SensitiveFilter处理Response,接着HTMLFilter处理Response.</p><p>好了,以上呢就是简单的讲解了责任链以及模拟了JavaEE中的Filter是如何实现的,欢迎留言一起交流</p><p>GitHub地址:</p><p><a href="https://github.com/wz-dazhi/designPatterns/tree/master/ChainOfResponsibility" target="_blank" rel="noopener">https://github.com/wz-dazhi/designPatterns/tree/master/ChainOfResponsibility</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式之工厂模式(Factory)</title>
    <url>/2018/06/23/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Factory/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><p>今天我们一起来回顾一下23中设计模式中的工厂模式,这里具体描述一下简单工厂方法,抽象工厂.以及简单理解Spring中的Bean工厂</p><a id="more"></a><h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法:#####"></a>工厂方法:#####</h5><p>来说这个工厂模式之前呢, 我们使用交通工具来描述这个工厂, 这样根据交通工具更能深入理解工厂模式.首先我们定义一个交通工具car, 既然是car, 那么它肯定有一个run方法,或者叫go也可以. 然后定义一个简单的测试类Test</p><p>Car.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个简单的类, 在Test客户端中new了一个car,将创建car的主动权交给了客户端.这样是没有安全性的,也就是说客户端想new几个car都可以.如果我们只想给客户端一个car呢?很简单, 将生产car的过程交给car自己是不是就可以了.下面我们修改一下代码</p><p>Car.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = Car.getInstance();</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将car的生产过程写在了car自己的类中, 并提供一个getInstance方法对外.有人会说, 你这不还是new car吗. 每次调用getInstance方法都拿到一个新的car,确实是这样. 但是有没有想过,将生产过程交给car自己的话, 并不是每次都能拿到一个car的.再比如说: 我家有个抽屉,有一抽屉钱, 你要new我 家一抽屉.但是我并不对外提供new的构造器,所以你就new不到, 而且你只能通过getInstance 方法拿到抽屉, 那如果我在getInstance方法做了判断呢? 你是我儿子就可以拿到抽屉,不是我就不给呢?这样想的话,是不是觉得还是有不一样的地方呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(你是司机) </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    <span class="keyword">if</span>(你是我儿子)</span><br><span class="line">        给你一个抽屉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才说到只给客户一辆车, 也就是只给一辆car, 那我们可以写成单例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Car CAR = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里面蕴含着两个设计模式,getInstance方法其实就是静态工厂方法,<code>return CAR</code>使用的就是单例模式. 通过这种方式客户端是不是只能拿到一个car了?不管调用多少次getInstance方法,拿到的都是same car. 既然这里提到了单例,那我就多说一点, 静态工厂方法呢也是工厂模式细微的延伸出来的一个概念.后来, 有人在单例上面也延伸了一个另一个概念, 看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Car&gt; cars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 将创建的car都装入容器之中</span></span><br><span class="line">        cars.add(<span class="keyword">new</span> Car());</span><br><span class="line">        cars.add(<span class="keyword">new</span> Car());</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错, 这叫多例, 相信学过JDBC的同学都知道数据库连接池, 连接池就是将所有的connection放到容器当中,在使用的过程中直接拿连接就可以使用了. 所以有些东西呢我们不需要知道叫什么, 因为每个人的叫法不一样, 我们只要知道其中的意思就可以了.没有必要跟人咬文嚼字的抬杠</p><p>ok我们接着说, 如果我们不想使用car了, 想换成飞机Plane,这个时候该怎么办呢? new一个class叫Plane, 如果我们想换成别的交通工具呢?比如扫帚. 这里我们考虑一个问题, <strong>注意: 任意定制交通工具的类型和生产过程.</strong> 所以为了以后的扩展性, 既然考虑扩展性,就必定少不了多态, 多态必定少不了父类.所以我们需要一个父类将所有的交通工具统一起来, 我们创建一个Interface,叫Moveable, 让所有的交通工具都实现Moveable,Moveable定义一个抽象的run方法,只有具体的交通工具才知道自身是如何移动的,所以具体的交通工具重写run方法.</p><p>Moveable.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Car.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Car CAR = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CAR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Plane.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路扇着翅膀飞奔而来plane..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意定制交通工具的类型, 这个其实挺容易的,就是上面定义的接口, 以后不管使用任何交通工具只要从Moveable继承实现就可以了.下面我们来实现交通工具的生产过程,<strong>注意:是任意交通工具的生产过程</strong> . 下面我们可以定义一个抽象类, 我叫它VehicleFactory, 再定义两个子类叫CarFactory,PlaneFactory,一个专门生产car,一个专门生产plane</p><p>VehicleFactory.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Moveable <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CarFactory.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PlaneFactory.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaneFactory</span> <span class="keyword">extends</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Moveable <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Plane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们实现了可以定制任意类型的交通工具和生产过程了, 看一下客户端Test类</p><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Car car = Car.getInstance();</span></span><br><span class="line">        VehicleFactory factory = <span class="keyword">new</span> PlaneFactory();</span><br><span class="line">        Moveable m = factory.create();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一路扇着翅膀飞奔而来plane...</span><br></pre></td></tr></table></figure><p>下面我们整体看下类图关系:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/factory-01.png" alt="01"></p><p>从类图可以看到, 我们每一个交通工具对应一个生产过程,并且还具有很好的扩展性, 比如我们想使用扫帚, 那么我们可以创建一个类Broom实现Moveable,当然Broom是魔法扫帚, 然后定义一个broom对应生产过程的工厂类,叫BroomFactory然后从VehicleFactory继承.以上说的就是简单工厂方法.</p><h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂:#####"></a>抽象工厂:#####</h5><p>说抽象工厂之前, 我们copy一份代码,将代码回到最原始</p><p>Car.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car c = <span class="keyword">new</span> Car();</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 我们的客户端是开着一辆车,现在呢我们的客户呢不只是开辆车, 在开车的同时呢手拿AK47, 而且嘴里还叼着苹果</p><p>AK47.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK47</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"哒哒哒AK47..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple.java 这里为了简单起见,打印一下食品 的名字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"苹果apple..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Car c &#x3D; new Car();</span><br><span class="line">        c.run();</span><br><span class="line">        AK47 ak47 &#x3D; new AK47();</span><br><span class="line">        ak47.shoot();</span><br><span class="line">        Apple apple &#x3D; new Apple();</span><br><span class="line">        apple.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类Test中我们可以看到,我们的客户不是使用单一的一个产品了, 而是一系列的产品. 如果我们也不想把生产过程交给客户, 因为有了经验, 我们可以使用工厂,这里需要注意的是, 我们定义的工厂不再是生产单一的产品,而是生产一系列的产品. 我们可以定义一个默认的工厂,这个工厂生产car,ak47,还有apple. 既然是默认的, 这里我取名叫DefaultFactory.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AK47 <span class="title">createAK47</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Apple <span class="title">createApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然使用了工厂,那么我们的客户类修改如下:</p><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultFactory f = <span class="keyword">new</span> DefaultFactory();</span><br><span class="line">        Car c = f.createCar();</span><br><span class="line">        c.run();</span><br><span class="line">        AK47 ak47 = f.createAK47();</span><br><span class="line">        ak47.shoot();</span><br><span class="line">        Apple apple = f.createApple();</span><br><span class="line">        apple.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看出,使用默认的工厂一下就可以生产出一系列的产品.当然,这还不是最灵活的, 要想当前代码有灵活度,有扩展性. 比如说我们不想使用这一系列的产品了,想换成魔法系列的产品. 这个时候改怎么办呢?这下我们就要考虑将一系列的产品统一抽象起来,并且将生产产品的工厂也统一抽象. 这样我们替换一系列产品的时候只需要换成对应的工厂就可以了. 下面我们定义一个统一的抽象工厂,我叫它AbstractFactory, 将所有生产一系列产品的工厂继承AbstractFactory,这样当我们想换一系列产品的时候,只需要替换系列工厂就ok了. 当然, 我们也需要将一系列产品统一抽象起来,定义一个抽象交通工具叫Vehicle,抽象的武器叫Weapon,抽象的食品叫Food. 然后具体产品继承抽象产品.下面撸代码</p><p>AbstractFactory.java 抽象的工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Weapon <span class="title">createWeapon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Food <span class="title">createFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象的一系列产品</p><p>Vehicle.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Weapon.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Food.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们默认的工厂继承抽象工厂</p><p>DefaultFactory.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weapon <span class="title">createWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">createFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的产品实现抽象的产品</p><p>Car.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AK47.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AK47</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"哒哒哒AK47..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"苹果apple..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory f = <span class="keyword">new</span> DefaultFactory();</span><br><span class="line">        Vehicle v = f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        Weapon w = f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        Food a = f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从客户端我们可以看出, 我们使用默认的工厂创造出了一系列的默认产品. 刚才我们说到, 我们想把产品系列换成一系列的魔法产品.那么我们可以创建一个扫帚, 我叫它Broom, 继承Vehicle. 创建一个魔法棒, 叫它MagicStick,继承Weapon(武器),创建一个毒蘑菇,叫它Mushroom. 接着创建一个魔法工厂,是专门来生产这一系列的魔法产品叫它MagicFactory.java 魔法工厂</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">createFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mushroom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Broom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weapon <span class="title">createWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MagicStick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MagicStick.java 魔法棒</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicStick</span> <span class="keyword">extends</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fire hu hu hu..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broom.java 扫帚</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broom</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路沙尘暴扫着土..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mushroom.java 毒蘑菇</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mushroom</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"毒蘑菇..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//AbstractFactory f = new DefaultFactory();</span></span><br><span class="line">        AbstractFactory f = <span class="keyword">new</span> MagicFactory();</span><br><span class="line">        Vehicle v = f.createVehicle();</span><br><span class="line">        v.run();</span><br><span class="line">        Weapon w = f.createWeapon();</span><br><span class="line">        w.shoot();</span><br><span class="line">        Food a = f.createFood();</span><br><span class="line">        a.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面整体看一下抽象工厂的类图,这个类图有点复杂,仔细看呢还是很容易看懂的:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/factory-02.png" alt="02"></p><p>写到这里呢, 抽象工厂算是讲完了. 从上面的类图可以看到, 我们将所有的产品抽象起来, 然后将生产一系列产品的工厂抽象统一起来.我们如果想要替换一系列的产品, 并且想要增加一系列新的产品, 并且想将一系列产品的生产过程交给可以生产出一系列产品的工厂,那么我们可以考虑使用抽象工厂.使用抽象工厂只需要修改抽象工厂的实现类就可以生产出我们需要的一系列的产品. 在以上的代码中,我们如果把替换的方式写在配置文件中, 甚至都不需要修改源代码.这就是抽象工厂</p><h5 id="抽象工厂对比普通工厂"><a href="#抽象工厂对比普通工厂" class="headerlink" title="抽象工厂对比普通工厂:#####"></a>抽象工厂对比普通工厂:#####</h5><ul><li><p>普通工厂:</p><p>对于普通工厂来说,我们是可以扩展产品的,可以产生新的产品,也可以产生新的产品工厂.也就是说我们可以在产品上面进行扩展.但是不可以产生工厂系列产品,比如说我们使用普通工厂生产一系列产品, 我们的系列产品每个产品都要创建一个产品工厂,最后我们会出现一个严重的问题,就是<strong>工厂泛滥</strong>.</p></li><li><p>抽象工厂:</p><p>对于抽象工厂来说, 我们可以替换产品系列, 我们可以创建新的产品系列.在产品系列上进行扩展.但是不可以生产新的产品品种,比如说我们想加一个新的产品品种, 那么我们就要在AbstractFactory加一个方法,然后所有的子类都要做改动,很麻烦.</p></li></ul><h5 id="Spring-Bean工厂"><a href="#Spring-Bean工厂" class="headerlink" title="Spring Bean工厂:#####"></a>Spring Bean工厂:#####</h5><p>为了理解Spring Bean工厂呢, 我们创建一个接口Moveable, 两个子类Car和Train. 以及Test测试类:</p><p>Moveable.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Car.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一路滴滴而来的car..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Train.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小火车呜呜呜..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Moveable m = <span class="keyword">new</span> Car();</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Test类中可以看到, 我们创建的方式是使用new的方式.而spring呢. 说你别new了, 你写到配置文件里.下面我们创建一个spring.properties, 然后修改Test类</p><p>spring.properties 这里为了简单起见,只写一句话</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VehicleType=com.wz.dp.springfactory.Train</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.load(Test.class.getClassLoader().getResourceAsStream("com/wz/dp/springfactory/spring.properties"));</span><br><span class="line">        String vehicleType = props.getProperty(<span class="string">"VehicleType"</span>);</span><br><span class="line">        Object o = Class.forName(vehicleType).newInstance();</span><br><span class="line">        Moveable m = (Moveable) o;</span><br><span class="line">        m.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/factory-03.png" alt="03"></p><p>这里写了一个配置文件,并读取配置文件,利用反射的机制创建对象. 这样的好处是我们以后都不需要修改代码了,只需要修改配置文件就可以拿到我们想要的实现对象.学过Spring的童鞋肯定知道, 在使用Spring的时候,我们想得到一个对象的话, 就将对象写到applicationContext.xml文件中, 写入</p><p><code>&lt;bean id=&quot;v&quot; class=&quot;com.wz.dp.springfactory.Car&quot;&gt;</code></p><p>在代码里使用BeanFactory调用getBean方法就可以拿到我们配置的类. 可以来回替换实现. 当然,有兴趣的朋友可以自己模拟Spring 的bean工厂, 写一个xml文件, java解析xml文件,将所有的对象放到一个map容器当中,当调用getBean的时候,就从容器里获取一个.这里不再模拟Spring了.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式之迭代器(Iterator)</title>
    <url>/2018/06/09/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><p>要说在我们平时工作中使用最多的模式, 我觉得不是个人模式, 不是工厂模式,而是迭代器模式(Iterator).迭代器在我们的程序编程中,确实是使用的最多的一个设计模式了. 因为只有有容器的出现, 就会有这个模式的存在.下面我们来详细的讲解一下这个模式.</p><a id="more"></a><h5 id="容器与容器遍历"><a href="#容器与容器遍历" class="headerlink" title="容器与容器遍历"></a>容器与容器遍历</h5><p>下面我们写两个容器,<code>ArrayList</code>, <code>LinkedList</code>. <strong>注意:</strong> 这里是我们自己写的两个容器, 并不是JDK给我们提供的. 为了模拟JDK, 所以取名一致.废话不多说, 上码</p><p>ArrayList.java, 既然是容器那么就肯定会有add()添加的方法, size()容器的大小.为了简单起见, 只定义这两个方法.为了让我们自己定义的这个容器可以存储任意类型,这里使用了Object[],初始值为10. 并且为了让我们的容器能够无限的添加, 也就是说当我们的容器数量超过了初始值10个, 那么我们就自动扩张容器的大小,为了简单起见当容器的数量超过规定的大小的时候, 我们就设置容器大小是原有容器的大小2倍,这样我们的容器就可以无限的添加任何数据了(前提是当前的机器有足够大的内存).当然, JDK中ArrayList的扩容算法并不是这样.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] objects = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引,记录有效数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断容器的容量是否超过规定的数量</span></span><br><span class="line">        <span class="keyword">if</span> (index == objects.length) &#123;</span><br><span class="line">            Object[] newObjects = <span class="keyword">new</span> Object[objects.length * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(objects, <span class="number">0</span>, newObjects, <span class="number">0</span>, objects.length);</span><br><span class="line">            objects = newObjects;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[index] = o;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList.java, 既然是LinkedList, 那么它的数据结构肯定是一个链表,所以这里定义一个Node节点, 在LinkedList中指定头节点和尾节点.那么肯定也少不了add()方法, size()方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(o, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 如果head为空,说明添加的是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head不为空的时候,就往尾部添加节点</span></span><br><span class="line">        tail.setNext(node);</span><br><span class="line">        tail = node;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node.java, 这里, 我们的Node节点也是可以存储任意类型的数据,所以使用Object类型.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试, 我们这里定义一个辅助类, 就叫Cat吧!</p><p>Cat.java, 一个简单的辅助类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是我们的Test类</p><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList</span><br><span class="line"><span class="comment">//        LinkedList list = new LinkedList();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Cat(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用的是我们自己定义的ArrayList,为了实验我们的ArrayList能够自动扩容,这里的存储对象是15只猫,运行程序.可以看到我们的size是15.</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/iterator-01.png" alt="1528526080599"></p><p>下面看一下整体类图:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/iterator-02.png" alt="1528522710780"></p><p>好了, 现在问题来了.在Test中我们使用的ArrayList, 那么我现在不想使用ArrayList了,我想使用LinkedList.如果我们现在换容器的话,唯一的做法就是修改代码, 将ArrayList注释掉, 换成LinkedList,如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new ArrayList</span></span><br><span class="line">        LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Cat(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我想,如果有一天我不想用LinkedList了, 我想用Vector, Set , HashSet等等. 那么我们每次都要修改代码吗?当然不是了, 这个做法也太low了. 为了避免以后发生改变,我们就要有约束.这里我们定义一个接口, 让我们的容器实现这个接口. 当然, 如果后续我们想用别的容器了,我们直接更换实现就好了.这里我定义一个接口,为了模拟JDK, 我们取名叫做Collection接口.让我们的容器实现这个接口.</p><p>Collection.java, 为了简单起见, 也只定义add()方法,size()方法.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了, 接口写完了. 我们的容器都实现这个接口, 当然实现之后并没有大的改变,为了规范. 我们在每一个实现类的<code>add()</code>,<code>size()</code> 这两个方法上面写上@Override.看下实现后的类图:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/iterator-03.png" alt="1528525686659"></p><p>下面我们修改客户端Test类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new ArrayList();</span></span><br><span class="line"><span class="comment">//        LinkedList list = new LinkedList();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//        Collection c = new LinkedList();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            c.add(<span class="keyword">new</span> Cat(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(c.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们复习了一下多态,父类的引用指向了子类对象. 这样的写法是不是美好了很多, 如果我们把这行代码写到配置文件中, 我们甚至都不需要修改代码.只需要修改我们想要的实现就可以了.好了,扯了这么多, 肯定会有人说不是要讲设计模式吗?不是要讲迭代器吗?别着急, 因为我们只要深刻的理解了多态, 我们就更加容易理解设计模式.下面我们就来讲这个Iterator. 大家都知道, 我们使用的容器, 最重要的是什么吗?当然是遍历了, 但是每一个容器的迭代遍历方式是不一样的,因为数据结构不同, 我们呈现给客户端的遍历方式也不相同. 如果客户端使用多个容器,岂不是要写多个不同遍历的方式?如果真是这样,那客户端岂不是疯了?所以我们需要把所有容器的遍历统一起来,定义一个抽象的迭代器,由具体的容器去实现这个迭代器, 因为只有具体实现的容器才更清楚自己需要怎样的遍历方式.我们只需提供给客户端一个迭代器,当然, 在我们的<code>Collection</code>集合接口中也需要返回一个迭代器,也就是说不管什么样的容器,只要实现了迭代器,我们就可以拿到这个迭代器的实现, 拿到迭代器就可以进行遍历了.下面我们写一个迭代器,为了模拟JDK,这里取名叫Iterator</p><p>Iterator.java, 既然是迭代器, 肯定会有下一个,是否还有下一个. 所以定义了两个方法<code>next()</code>,<code>hasNext()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的<code>Collection</code>接口中增加一个方法, 返回这个迭代器</p><p>Collection.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改我们容器的具体实现, 并返回当前具体容器需要遍历迭代的具体实现.</p><p>修改后的ArrayList.java,这里使用了内部私有类ArrayListIterator, 实现了Iterator接口.在ArrayList中向客户端提供一个Iterator具体实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">implements</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] objects = <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引,记录有效数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断容器的容量是否超过规定的数量</span></span><br><span class="line">        <span class="keyword">if</span> (index == objects.length) &#123;</span><br><span class="line">            Object[] newObjects = <span class="keyword">new</span> Object[objects.length * <span class="number">2</span>];</span><br><span class="line">            System.arraycopy(objects, <span class="number">0</span>, newObjects, <span class="number">0</span>, objects.length);</span><br><span class="line">            objects = newObjects;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[index] = o;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object o = objects[currentIndex];</span><br><span class="line">            currentIndex++;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= index) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的LinkedList.java, 这里也是使用内部私有类我们取名叫LinkedListIterator,并实现Iterator接口.在LinkedList中也向客户端返回一个Iterator的具体实现.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> <span class="keyword">implements</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(o, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 如果head为空,说明添加的是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head不为空的时候,就往尾部添加节点</span></span><br><span class="line">        tail.setNext(node);</span><br><span class="line">        tail = node;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object o = head.getData();</span><br><span class="line">            head = head.getNext();</span><br><span class="line">            currentIndex++;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (currentIndex &gt;= index) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后看一下我们的客户端Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ArrayList list = new ArrayList();</span></span><br><span class="line"><span class="comment">//        LinkedList list = new LinkedList();</span></span><br><span class="line"><span class="comment">//        Collection c = new ArrayList();</span></span><br><span class="line">        Collection c = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            c.add(<span class="keyword">new</span> Cat(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(c.size());</span><br><span class="line"></span><br><span class="line">        Iterator iterator = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Object o = iterator.next();</span><br><span class="line">            System.out.print(o + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下运行结果, 因为我们的Cat类中重写了toString方法, 所以可以直接打印出来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span></span><br><span class="line">Cat&#123;id=<span class="number">0</span>&#125; Cat&#123;id=<span class="number">1</span>&#125; Cat&#123;id=<span class="number">2</span>&#125; Cat&#123;id=<span class="number">3</span>&#125; Cat&#123;id=<span class="number">4</span>&#125; Cat&#123;id=<span class="number">5</span>&#125; Cat&#123;id=<span class="number">6</span>&#125; Cat&#123;id=<span class="number">7</span>&#125; Cat&#123;id=<span class="number">8</span>&#125; Cat&#123;id=<span class="number">9</span>&#125; Cat&#123;id=<span class="number">10</span>&#125; Cat&#123;id=<span class="number">11</span>&#125; Cat&#123;id=<span class="number">12</span>&#125; Cat&#123;id=<span class="number">13</span>&#125; Cat&#123;id=<span class="number">14</span>&#125; </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到, 我们这个迭代器实现了. 上面使用的是LinkedList, 如果我们换成ArrayList的话, 只需要更换一个具体实现就可以了.现在世界是不是美好了很多.</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结:#####"></a>总结:#####</h5><ol><li>根据我们上面所讲,可以看出迭代器模式的结构可以分为以下几种:<ul><li>抽象迭代器</li><li>具体的迭代实现</li><li>抽象容器</li><li>具体的容器实现</li></ul></li><li>迭代器的优点<ul><li>它支持以不同的方式遍历一个聚合对象,在同一聚合上可以有多个遍历方式</li><li>简化了遍历方式, 客户端只需得到迭代器就可以进行遍历</li><li>客户端不必关心具体容器遍历算法</li><li>在迭代器模式中, 增加新的聚合类和迭代类,无需修改原有的代码</li></ul></li><li>迭代器的缺点<ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li></ul></li><li>模式总结<ul><li>迭代器模式提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。</li><li>将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是“单一职责原则”的完美体现。</li><li>当使用迭代器的时候，我们依赖聚合提供遍历。</li><li>迭代器提供了一个通用的接口，让我们遍历聚合的项，放我们编码使用聚合项时，就可以使用多态机制。</li></ul></li></ol><p>GitHub项目地址: <a href="https://github.com/wz-dazhi/designPatterns/tree/master/Iterator/src/com/wz/dp/iterator" target="_blank" rel="noopener">Iterator</a></p><p><strong>转载请注明此处:</strong></p><p><a href="http://hexo.dazhi.info/2018/06/09/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator.html" target="_blank" rel="noopener">http://hexo.dazhi.info/2018/06/09/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator.html</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用frp实现内网穿透</title>
    <url>/2019/09/19/%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><ol><li><p>一台公网服务器(腾讯云, 阿里云 … 只要有外网ip的都可以)</p></li><li><p>一台内网机器(没有外网ip, 只有内网ip, 但是可以访问外部网络)</p></li></ol><a id="more"></a><ol start="3"><li><p>下载frp软件</p><ul><li><p>GitHub地址(可以获取最新版): <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p></li><li><p>网盘下载(0.29.0版本): 链接:<a href="https://pan.baidu.com/s/1muHqT-g-Ocn6aTKg5l_cHQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1muHqT-g-Ocn6aTKg5l_cHQ</a> 密码:gefm</p></li></ul></li></ol><h5 id="公网服务器配置"><a href="#公网服务器配置" class="headerlink" title="公网服务器配置"></a>公网服务器配置</h5><ul><li>将frp软件传到服务器上(这里使用腾讯云)</li><li>腾讯云安全组配置, 开放端口:<ul><li>7000 (frp 服务端绑定端口)</li><li>9000 (frp http 访问端口)</li><li>6000 (frp ssh 连接端口)</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除客户端相关文件</span></span><br><span class="line">rm -rf frpc*</span><br></pre></td></tr></table></figure><ul><li>编辑frps.ini文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端绑定端口</span></span><br><span class="line">bind_port = 7000</span><br><span class="line"><span class="meta">#</span><span class="bash"> http对外暴露的端口</span></span><br><span class="line">vhost_http_port = 9000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nexus web服务</span></span><br><span class="line">[nexus]</span><br><span class="line">type = http</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要将 nexus.dazhi.info 域名解析到外网ip</span></span><br><span class="line">custom_domains = nexus.dazhi.info</span><br><span class="line">auth_token = nexus</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx web服务</span></span><br><span class="line">[nginx]</span><br><span class="line">type = http</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要将 nginx.dazhi.info 域名解析到外网ip</span></span><br><span class="line">custom_domains = nginx.dazhi.info</span><br><span class="line">auth_token = nginx</span><br></pre></td></tr></table></figure><ul><li>启动frp 服务端</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可以查看启动日志</span></span><br><span class="line">./frps -c ./frps.ini</span><br><span class="line"><span class="meta">#</span><span class="bash">后台运行</span></span><br><span class="line">nohup ./frps -c ./frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h5 id="内网服务器配置"><a href="#内网服务器配置" class="headerlink" title="内网服务器配置"></a>内网服务器配置</h5><ul><li>将frp软件传到内网机器上</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf frp_0.29.0_linux_amd64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除服务端相关文件</span></span><br><span class="line">rm -rf frps*</span><br></pre></td></tr></table></figure><ul><li>编辑frpc.ini文件</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 公网服务器ip地址</span></span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 公网服务器frp 绑定的端口</span></span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地frp管理</span></span><br><span class="line">admin_addr = 127.0.0.1</span><br><span class="line">admin_port = 7400</span><br><span class="line">admin_user = admin</span><br><span class="line">admin_pwd = admin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh配置</span></span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nexus web服务</span></span><br><span class="line">[nexus]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 9090</span><br><span class="line">auth_token = nexus</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要将 nexus.dazhi.info 域名解析到外网ip</span></span><br><span class="line">custom_domains = nexus.dazhi.info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx web服务</span></span><br><span class="line">[nginx]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 80</span><br><span class="line">auth_token = nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要将 nginx.dazhi.info 域名解析到外网ip</span></span><br><span class="line">custom_domains = nginx.dazhi.info</span><br></pre></td></tr></table></figure><ul><li>启动frp 客户端</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可以查看启动日志</span></span><br><span class="line">./frpc -c ./frpc.ini</span><br><span class="line"><span class="meta">#</span><span class="bash">后台运行</span></span><br><span class="line">nohup ./frpc -c ./frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h5 id="使用第三台电脑进行访问"><a href="#使用第三台电脑进行访问" class="headerlink" title="使用第三台电脑进行访问"></a>使用第三台电脑进行访问</h5><ul><li>ssh 连接</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root 为内网机器登录用户名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x.x.x.x 为外网ip地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回车后输入内网机器登录密码</span></span><br><span class="line">ssh -oPort=6000 root@x.x.x.x</span><br></pre></td></tr></table></figure><ul><li>nginx web 访问<br><a href="http://nginx.dazhi.info:9000/" target="_blank" rel="noopener">http://nginx.dazhi.info:9000/</a></li><li>nexus web 访问<br><a href="http://nexus.dazhi.info:9000/" target="_blank" rel="noopener">http://nexus.dazhi.info:9000/</a></li></ul><h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h5><ol><li><p>至此就完成了内网穿透</p></li><li><p>更多配置访问frp官方文档.</p><p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p></li></ol><p><strong>有问题的同学加QQ: 742820195,欢迎讨论交流.</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo+GitHub搭建博客</title>
    <url>/2018/05/23/%E4%BD%BF%E7%94%A8Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>编写本章的主要目的是为了帮助那些一直想搭建博客的同学一个参考,本章搭建博客使用的是Hexo+GitHub,Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 详细了解<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo</a>,使用GitHub的原因是GitHub提供的GitHub pages 是免费的,我们只需创建一个仓库就可以使用,GitHub官方建议每个存储库保持在1GB以下。如果大型文件不在存储库中，此限制很容易保留。如果您的存储库超过1GB，则可能会收到来自GitHub支持的礼貌电子邮件，要求您减少存储库的大小以使其恢复。 对于我们这些技术人员来说,写博客无疑是为了分享自己的技术,还有一点也是为了我们后续可以拿我们自己写的文章来进行复习。所以1GB对我们来说已经足够了。还有重要的一点是博客完全托管在github上，基本上不需要花时间去管理，博客使用Markdown语法，上手很容易。</p><a id="more"></a><h5 id="搭建需要了解的内容"><a href="#搭建需要了解的内容" class="headerlink" title="搭建需要了解的内容"></a>搭建需要了解的内容</h5><ol><li>Git安装以及常用命令</li><li>Nodejs安装</li><li>Markdown语法</li></ol><h5 id="本地安装Git"><a href="#本地安装Git" class="headerlink" title="本地安装Git"></a>本地安装Git</h5><ol><li>下载<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li>安装Git,不会安装Git的同学可以自行百度安装</li></ol><h5 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h5><blockquote><p>已有账号的用户可以略过</p></blockquote><ol><li>打开<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>官网</li><li>填写注册信息进行注册,注册成功后登陆GitHub</li></ol><h5 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h5><ol><li>在GitHub首页点击头像左边的+号,或者点击下三角符号按钮(New Repository按钮)创建仓库。 <img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/hexo/GitHub%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%931.png" alt="GitHub创建仓库1"></li><li>填写仓库创建信息: 仓库名称必须是 yourname.github.io(其中yourname是自己GitHub的用户名)。</li><li>填写好相关信息,点击<strong>Create repository(创建仓库)</strong>按钮。 (由于我已经创建,所以显示已经存在)<img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/hexo/GitHub%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%932.png" alt="GitHub创建仓库2"></li></ol><h5 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h5><ol><li><p>打开Git Bash终端,设置user name 和user email:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>生成ssh密钥:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</span><br></pre></td></tr></table></figure><p>此时，在用户文件夹下就会有一个新的文件夹<strong>.ssh</strong>，里面有刚刚创建的ssh密钥文件<strong>id_rsa</strong>和<strong>id_rsa.pub</strong>。</p><p><em>注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。</em></p></li><li><p>添加公钥到github :</p><ul><li>点击用户头像，然后点击显示的<strong>Settings(设置)</strong>选项；</li><li>在用户设置栏，点击<strong>SSH and GPG keys</strong>选项，然后点击<strong>New SSH key(新建SSH)</strong>按钮；</li><li>将id_rsa.pub中的内容复制到<strong>Key</strong>文本框中，然后点击<strong>Add SSH key(添加SSH)</strong>按钮；</li></ul></li><li><p>测试SSH：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>接下来会出来下面的确认信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established. </span><br><span class="line">RSA key fingerprint is 17:24:ac:a5:76:28:24:36:62:1b:36:4d:eb:df:a6:45.</span><br><span class="line"> Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure><p>输入yes,回车。 显示如下信息则说明OK。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi yourname! You&#39;ve successfully authenticated, </span><br><span class="line">but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></li></ol><h5 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h5><ol><li><p>新建仓库文件夹：这里就取名为blog。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir blog</span><br></pre></td></tr></table></figure></li><li><p>进入到blog文件夹：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd blog # 切换到blog目录</span><br></pre></td></tr></table></figure></li></ol><h5 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h5><ol><li><p>下载<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs</a>,然后安装</p></li><li><p>接着安装Hexo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g &#x2F;&#x2F; hexo全局安装</span><br><span class="line">hexo init  &#x2F;&#x2F; 初始化Hexo</span><br><span class="line">npm install  &#x2F;&#x2F; 安装依赖</span><br><span class="line">hexo server  &#x2F;&#x2F; 启动Hexo</span><br></pre></td></tr></table></figure><p>启动之后，打开浏览器，在地址栏输入：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000">http://localhost:4000</a>，你会看到Hexo的示例页面。</p><p><em>注：此时可以初始化git本地仓库了，或者是等本地博客搭建好之后也可以。</em></p></li></ol><h5 id="再探Hexo"><a href="#再探Hexo" class="headerlink" title="再探Hexo"></a>再探Hexo</h5><ol><li><p>新建文章：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><p>此时在<strong>source_posts</strong>文件夹中便会多出一个文档”title.md”. 如果要删除，直接在此文件夹下删除对应的文件即可。</p></li><li><p>生成静态页面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成的静态内容在<strong>public</strong>文件夹内。</p></li><li><p>清除生成内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>执行此操作会删除<strong>public</strong>文件夹中的内容。</p></li></ol><h5 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h5><ol><li><p>编辑配置文件，关联远程仓库： 在编辑器中打开Hexo配置文件<strong>_config.yml</strong>，找到下面内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><p>配置为GitHub仓库信息:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:wz-dazhi&#x2F;wz-dazhi.github.io.git #github仓库地址</span><br><span class="line">  branch: master # github分支</span><br></pre></td></tr></table></figure><p>由于<strong>_config.yml</strong>文件是属于yml格式的,所以注意配置的时候 <strong>:</strong> 后面都接一个空格</p></li><li><p>安装git插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>部署</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>如果没有意外的话,部署就成功了,可以打开浏览器访问<a href="">yourname.github.io</a> 查看。</p></li></ol><h5 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h5><blockquote><p>hexo 命令缩写</p></blockquote><p><strong>hexo g</strong>：hexo generate</p><p><strong>hexo c</strong>：hexo clean</p><p><strong>hexo s</strong>：hexo server</p><p><strong>hexo d</strong>：hexo deploy</p><blockquote><p>hexo 命令组合</p></blockquote><p>hexo clean &amp;&amp; hexo g -s，就是清除、生成、启动</p><p>hexo clean &amp;&amp; hexo g -d，就是清除、生成、部署</p><p>本文介绍了hexo+github的简单搭建,本文基本上抄袭了知乎Hexo专栏第一章。</p><p>前往专栏: <a href="https://zhuanlan.zhihu.com/z-hexo" target="_blank" rel="noopener">手把手教从零开始在GitHub上使用Hexo搭建博客教程</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenFeign实现文件上传</title>
    <url>/2020/05/01/%E4%BD%BF%E7%94%A8openfeign%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本文使用Spring Cloud OpenFeign 进行服务于服务之间的文件传输。在工作中，往往需要进行文件的上传下载功能，如果多个业务都需要文件的上传，可以单独的将文件服务抽离出来一个单独的文件服务对外暴露提供服务。下面写个demo使用OpenFeign进行单个文件传输、多个文件传输。</p><p><strong><em>注意： 对于SpringCloud的服务发现本文不做重点讨论，读者可以自行百度实现。以下示列只展示服务于服务之间文件传输的核心代码，涉及到的代码都会列出来。</em></strong></p></blockquote><a id="more"></a><ol><li><p>文件服务</p><ol><li><p>创建文件服务项目，编写pom.xml</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;!-- Spring Cloud --&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;Greenwich.SR2&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">		&lt;!-- Eureka Client --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 支持feign传递多个MultipartFile，并使用Form表单的方式提交 --&gt;</span><br><span class="line">        &lt;!-- &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;feign-form&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt; --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Lombok 省去get set方法 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置OpenFeign，让OpenFeign支持单文件、多文件传输（默认情况下OpenFeign只支持单文件传输）。</p><ol><li><p>feign-form-spring 这个包里有一个SpringFormEncoder，这个类是可以支持上传文件的，但是经过测试发现。 如果上传多个文件的情况下，文件服务只会接收到一个文件， 经过debug发现，该类的encode方法遍历了数组，遍历数组的时候 map里放的file.getName() 属于@RequestPart(“”) 里的name，导致map会进行覆盖。所以我这里照着SpringFormEncoder encode方法自己实现了一个。</p></li><li><p>首先查看SpringFormEncoder encode的实现</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/springcloud/openfeign/fd6d577556e5bda5b79c8783b79ffdba-222772-20200501152931020.png" alt="SpringFormEncode encode方法"></p></li><li><p>这里仿照上面的方法，自定义对encode方法进行实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFormEncoder</span> <span class="keyword">extends</span> <span class="title">FormEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomFormEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> Encoder.Default());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomFormEncoder</span><span class="params">(Encoder delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(delegate);</span><br><span class="line">        MultipartFormContentProcessor processor = (MultipartFormContentProcessor) getContentProcessor(MULTIPART);</span><br><span class="line">        processor.addFirstWriter(<span class="keyword">new</span> SpringSingleMultipartFileWriter());</span><br><span class="line">        processor.addFirstWriter(<span class="keyword">new</span> SpringManyMultipartFilesWriter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="keyword">throws</span> EncodeException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bodyType.equals(MultipartFile[]<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            MultipartFile[] files = (MultipartFile[]) object;</span><br><span class="line">            Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;(files.length);</span><br><span class="line">            <span class="comment">// object 文件数组都装到同一个@RequestPart()的name中</span></span><br><span class="line">            data.put(files[<span class="number">0</span>].getName(), object);</span><br><span class="line">            <span class="keyword">super</span>.encode(data, MAP_STRING_WILDCARD, template);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bodyType.equals(MultipartFile<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            MultipartFile file = (MultipartFile) object;</span><br><span class="line">            Map&lt;String, Object&gt; data = singletonMap(file.getName(), object);</span><br><span class="line">            <span class="comment">// 单个文件直接调用父类</span></span><br><span class="line">            <span class="keyword">super</span>.encode(data, MAP_STRING_WILDCARD, template);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMultipartFileCollection(object)) &#123;</span><br><span class="line">            Iterable&lt;?&gt; iterable = (Iterable&lt;?&gt;) object;</span><br><span class="line">            Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            String partName = ((MultipartFile) iterable.iterator().next()).getName();</span><br><span class="line">            <span class="comment">// 逻辑跟上面文件数组一样</span></span><br><span class="line">            data.put(partName, object);</span><br><span class="line">            <span class="keyword">super</span>.encode(data, MAP_STRING_WILDCARD, template);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.encode(object, bodyType, template);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMultipartFileCollection</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Iterable)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterable&lt;?&gt; iterable = (Iterable&lt;?&gt;) object;</span><br><span class="line">        Iterator iterator = iterable.iterator();</span><br><span class="line">        <span class="keyword">return</span> iterator.hasNext() &amp;&amp; iterator.next() <span class="keyword">instanceof</span> MultipartFile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>编写Controller，对外提供http服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个文件上传，直接使用MultipartFile对象接收文件</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(@RequestPart(<span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------file: "</span> + file);</span><br><span class="line">        System.out.println(<span class="string">"------------file name: "</span> + file.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进来了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 多个文件上传，直接使用MultipartFile数组接收文件</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload2"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload2</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> MultipartFile[] files) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------files: "</span> + Arrays.toString(files));</span><br><span class="line">        System.out.println(<span class="string">"------------file length: "</span> + files.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进来了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个文件数组上传，并添加额外参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload3"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload3</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> MultipartFile[] files, @<span class="title">RequestParam</span><span class="params">(<span class="string">"json"</span>)</span> String json) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------files: "</span> + Arrays.toString(files) + <span class="string">", json: "</span> + json);</span><br><span class="line">        System.out.println(<span class="string">"------------file length: "</span> + files.length);</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile f : files) &#123;</span><br><span class="line">            System.out.println(<span class="string">"----file name: "</span> + f.getOriginalFilename());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进来了 - "</span> + json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个文件List上传，并添加额外参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload4"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload4</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> List&lt;MultipartFile&gt; files, @<span class="title">RequestParam</span><span class="params">(<span class="string">"json"</span>)</span> String json) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------List files: "</span> + files + <span class="string">", json: "</span> + json);</span><br><span class="line">        System.out.println(<span class="string">"------------List file length: "</span> + files.size());</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile f : files) &#123;</span><br><span class="line">            System.out.println(<span class="string">"----List file name: "</span> + f.getOriginalFilename());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进来了 - "</span> + json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义对象接收文件和参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload5"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload5</span><span class="params">(Files files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------------Bean files: "</span> + files);</span><br><span class="line">        System.out.println(<span class="string">"------------Bean file length: "</span> + files.files.size());</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile f : files.files) &#123;</span><br><span class="line">            System.out.println(<span class="string">"----Bean file name: "</span> + f.getOriginalFilename());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进来了 - "</span> + files;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 自定义对象</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Files</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;MultipartFile&gt; files;</span><br><span class="line">        <span class="keyword">private</span> String userNo;</span><br><span class="line">        <span class="keyword">private</span> String mobile;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cardType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Client、配置OpenFeign，将自定义的Encode进行配置，该类打成jar直接对业务服务使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解配置熔断器和自定义Encoder配置</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"demo"</span>, contextId = <span class="string">"FileClient"</span>, path = <span class="string">"/file"</span>, fallback = FileHystrix<span class="class">.<span class="keyword">class</span>, <span class="title">configuration</span> </span>= FileClient.MultipartConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">FileClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(@RequestPart(<span class="string">"file"</span>)</span> MultipartFile file)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload2"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function">String <span class="title">upload2</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> MultipartFile[] files)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload3"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function">String <span class="title">upload3</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> MultipartFile[] files, @<span class="title">RequestParam</span><span class="params">(<span class="string">"json"</span>)</span> String json)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload3"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function">String <span class="title">upload4</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> List&lt;MultipartFile&gt; files, @<span class="title">RequestParam</span><span class="params">(<span class="string">"json"</span>)</span> String json)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/upload5"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function">String <span class="title">upload5</span><span class="params">(Files files)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultipartConfig</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line">        <span class="comment">// 配置定义Encoder</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignFormEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CustomFormEncoder(<span class="keyword">new</span> SpringEncoder(messageConverters));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打开日志进行观察</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">fileFeignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于client 跟上面的Controller不处于同一个模块，所以这个自定义对象又写了一遍，以供Client使用</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Files</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;MultipartFile&gt; files;</span><br><span class="line">        <span class="keyword">private</span> String userNo;</span><br><span class="line">        <span class="keyword">private</span> String mobile;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cardType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client 熔断简单实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHystrix</span> <span class="keyword">implements</span> <span class="title">FileClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入熔断了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload2</span><span class="params">(MultipartFile[] files)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入熔断了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入熔断了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload4</span><span class="params">(List&lt;MultipartFile&gt; files, String json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入熔断了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload3</span><span class="params">(MultipartFile[] files, String json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入熔断了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload5</span><span class="params">(Files files)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"进入熔断了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>业务服务</p><ol><li><p>这边只是一个简单的SpringCloud的项目，pom跟上面的依赖差不多。<strong>*<font color="red">注意：另外需要引入Client模块的jar包</font>*</strong></p></li><li><p>Controller具体代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/kyc"</span>)</span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KycController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引入FileClient，像调本地方法一样调用文件服务。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileClient fileClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileClient.index();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 单个文件</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">demo</span><span class="params">(@RequestPart(<span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileClient.upload(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 多个文件-数组</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/demo2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">demo2</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> MultipartFile[] files) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-------demo2 files: &#123;&#125;"</span>, files.length);</span><br><span class="line">        <span class="keyword">return</span> fileClient.upload2(files);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 多个文件-数组，内部存在额外参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/demo3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">demo3</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> MultipartFile[] files) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-------demo3 files: &#123;&#125;"</span>, files.length);</span><br><span class="line">        <span class="keyword">return</span> fileClient.upload3(files, <span class="string">"&#123;hhhhhhhhhhh&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 对象，文件列表和json对象</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/demo4"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">demo4</span><span class="params">(FileClient.Files files)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-------demo4 files: &#123;&#125;"</span>, files);</span><br><span class="line">        FileUpload2 f = <span class="keyword">new</span> FileUpload2();</span><br><span class="line">        BeanUtils.copyProperties(files, f);</span><br><span class="line">        <span class="keyword">return</span> fileClient.upload4(files.getFiles(), JSONObject.toJSONString(f));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 列表文件</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/demo5"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">demo5</span><span class="params">(@RequestPart(<span class="string">"files"</span>)</span> List&lt;MultipartFile&gt; files) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-------demo5 files: &#123;&#125;"</span>, files);</span><br><span class="line">        <span class="keyword">return</span> fileClient.upload4(files, <span class="string">"&#123;demo5 files&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接传实体, 带参数</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/demo6"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">demo6</span><span class="params">(FileClient.Files files)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-------demo6 files: &#123;&#125;"</span>, files);</span><br><span class="line">        <span class="keyword">return</span> fileClient.upload5(files);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Postman测试</p><ol><li><p>单个文件 <code>/demo</code></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/springcloud/openfeign/9d922c20433b24c0a1f04013474e96b8-78890.png" alt="单个文件测试"></p></li><li><p>多个文件-数组 <code>/demo2</code></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/springcloud/openfeign/9b264f3dabc758bbea003f197c4f86e5-94789.png" alt="img"></p></li><li><p>多个文件-数组，Controller内部加入额外的参数 <code>/demo3</code></p><p><img src="https://app.yinxiang.com/FileSharing.action?hash=1/3c05fb48fd06ceee6080cbeff38b380f-98983" alt="img"></p></li><li><p>传输文件实体，Controller内部将文件列表和对象参数分开传输 <code>/demo4</code></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/springcloud/openfeign/fe31b74573e61e91f5bb26928fd3a01c-127617.png" alt="img"></p></li><li><p>多个文件-List <code>/demo5</code>，跟<code>/demo4</code>没什么区别，调用同一个client方法</p><p><img src="https://app.yinxiang.com/FileSharing.action?hash=1/5491ae6126607a63577a1008f1a2433c-95274" alt="img"></p></li><li><p>直接传输实体 <code>/demo6</code></p><p><img src="https://app.yinxiang.com/FileSharing.action?hash=1/f09258b39307dfb22fe26cdafb9905f2-203216" alt="img"></p></li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>通过以上代码实现了单文件、多文件的文件服务，果然多看源码是有好处的，不然问题都不知道在哪里出现的。这里需要注意的是在使用SpringCloud的时候，要确保SpringCloud的版本和SpringBoot的版本需要相对应，不然会出现意想不到的问题。具体版本对应自行百度。</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式之策略模式(Strategy)</title>
    <url>/2018/06/02/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><p>今天我们一起来学习java设计模式中的策略模式(Strategy),以及C&amp;C接口的详细解析.</p><p>一天, 我们接到了项目经理发来的一个需求, 说 给我实现一个数组,并排序,然后给我打印出来. 简单,下面我们来实现这个需求</p><p>首先, 我们new 一个class, 为了方便这里取名Test. 然后定义一个int数组, 再写一个对数组排序的静态方法(排序, 打印)</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">23</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">DataSorter.sort(arr);</span><br><span class="line">DataSorter.print(arr);</span><br></pre></td></tr></table></figure><p>下面我们实现这个DateSorter这个类, 一个简单的冒泡排序和一个打印方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 排序(只能排序int数组)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 交换(int类型)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">       arr[x] = arr[y];</span><br><span class="line">       arr[y] = temp;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 打印</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>好了, 功能实现完了. 我们看一下类图:<br><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/strategy-01.png" alt="1527918918520"></p><p>从上图,我们可以看到实现这个小程序是非常的简单. 而且心里美滋滋, 突然项目经理过来说,我现在不想使用数字进行排序了, 我家里有几只猫, 我想对猫进行排序. 这个时候我们的第一想法,肯定是得有一个Cat类, 为了简单起见我们定义两个属性,一个height高度, 一个weight重量.当然我们得修改DataSorter类中的排序方法, 既然我们现在是对猫进行排序, 所以我们需要对sort方法进行改造,为了方便我们增加一个sort方法, 对sort方法 <code>public static void sort(int[] arr)</code> 将<code>int[]</code> 改为<code>Cat[]</code>. 这样修改的话, 我觉得大家一眼就看出有问题了, 如果有一天我们不想根据猫排序了, 我们想根据狗来排序, 那我们是不是还得加一个狗的排序方法? 如果我们不想根据狗排序,我们想根据牛, 羊等等… 那我们是不是需要加更多更多的sort方法.所以,到了这里我们为了能够统一<code>天下</code>, 我们将sort方法的参数改为<code>Object[] arr</code>. 当然改成这个并不能满足我们当前这种情况,因为这样写的话,我们并不知道Object改如何来进行排序, 因为我们需要将Object强转成我们需要的Cat类. 那么这个sort方法也不够灵活,以后我们根据狗排序的话,是不是还得需要修改sort方法. 所以我们为了不去修改sort方法, 我们这里自己定义个比较接口,让具体的类去实现这个接口,该怎么比较,具体的类说了算,类图如下:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/strategy-02.png" alt="1527920641942"></p><p>具体代码如下:</p><p>Test.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cat[] arr = &#123;<span class="keyword">new</span> Cat(<span class="number">5</span>, <span class="number">5</span>), <span class="keyword">new</span> Cat(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> Cat(<span class="number">3</span>, <span class="number">3</span>)&#125;;</span><br><span class="line">    DataSorter.sort(arr);</span><br><span class="line">    DataSorter.print(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataSorter.java</p><p>因为我们需要比较任意类型, 所以sort方法可以强转为Comparable接口. (前提比较的类型都必须实现Comparable接口)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序(可以排序所有类型的数组)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            Comparable c1 = (Comparable) arr[j];</span><br><span class="line">            Comparable c2 = (Comparable) arr[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c1.compareTo(c2) == -<span class="number">1</span>) &#123;</span><br><span class="line">                swap(arr, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换(Object类型)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Object[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Object temp = arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印(为了方便起见, 打印这个方法,只打印Cat)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Cat[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Cat i : arr) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Comparable.java</p><p><strong>注意:</strong> 这里是我们自己定义的Comparable接口,而不是JDK给我们提供的(这里为了模拟JDK,所以取名一样)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat.java</p><p><strong>注意:</strong> 这里实现的是我们自己定义的Comparable接口,而不是JDK给我们提供的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的Comparable接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.height &gt; cat.getHeight()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.height &lt; cat.getHeight()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略get set  toString ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了, 现在我们写了一个对猫的排序,我们说前面的猫比后面猫的高度低,就返回-1, 然后进行交换排序.结果这里就不演示了. 现在我们回过头来想一下, 现在我们这个是否已经满足了对所有类型的排序呢?答案是否定的, 在上面的代码中我们可以看到我们现在是对猫的高度进行排序,虽然我们对于sort方法是满足了对所有类型的排序.但是我们具体的比较是根据高度,还是根据重量都是在我们具体的Cat类中进行编码的, 如果我们对猫的重量排序,是不是还得需要修改Cat类中的代码? 所以说现在还是不够灵活, 为了满足这个需求呢. 这里我们定义比较器, 定义一个比较策略的接口, 让具体的比较策略都去实现这个比较器.先看java代码:</p><p>Comparator.java</p><p><strong>注意:</strong> 这里是我们自己定义的Comparator接口(这里为了模拟JDK,所以取名一样)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改Cat.java 如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用比较策略, 这里根据高度进行比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> Comparator comparator = <span class="keyword">new</span> CatHeightComparator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的Comparable接口, Comparator接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(<span class="keyword">this</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略get set  toString ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较高度的Comparator具体实现,CatHeightComparator.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatHeightComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Cat c1 = (Cat) o1;</span><br><span class="line">        Cat c2 = (Cat) o2;</span><br><span class="line">        <span class="keyword">if</span> (c1.getHeight() &gt; c2.getHeight()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c1.getHeight() &lt; c2.getHeight()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/strategy-03.png" alt="1527922396113"></p><p>现在我们回到刚才的问题, 我们需要根据重量进行排序, 那我们现在就写一个根据重量的比较策略</p><p>CatWeightComparator.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatWeightComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Cat c1 = (Cat) o1;</span><br><span class="line">        Cat c2 = (Cat) o2;</span><br><span class="line">        <span class="keyword">if</span> (c1.getWeight() &gt; c2.getWeight()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c1.getWeight() &lt; c2.getWeight()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Cat的比较策略实现, 其余代码不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用比较策略, 这里根据重量进行比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// private Comparator comparator = new CatHeightComparator();</span></span><br><span class="line"><span class="keyword">private</span> Comparator comparator = <span class="keyword">new</span> CatWeightComparator();</span><br></pre></td></tr></table></figure><p>现在我们整体来看一下类图结构:</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/java/design/strategy-04.png" alt="1527922764616"></p><h5 id="结尾"><a href="#结尾" class="headerlink" title="结尾:"></a>结尾:</h5><p>策略模式说到这里, 我想大家是不是一下子感觉世界美好了很多. 以后我们对猫的前面两只爪进行排序, 对猫的胡须进行排序, 对猫的第一根毛的长度,第二根毛的长度… 等等, 我们只需要修改对应的比较策略是不是就ok了. 根据现实生活中,比如我们坐火车去东北, 坐飞机去东北, 坐轮船, 骑扫帚(哈利波特)… 骑大治哥(不好意思,不可以), 我们只需要更换对应的策略,是不是就能满足我们的需求. 我想现在大家基本上理解了策略模式,以及C&amp;C接口.</p><p>其实到最后, 我们完全没有必要自己写排序算法, 自己写C&amp;C接口. JDK都已经全都帮我们实现了,现在我们修改成JDK为我们提供的</p><p>Cat.java</p><p><strong>注意:</strong> 为了突出我们使用的是JDK提供的, 这里加上了权限类名. <code>java.lang.Comparable&lt;T&gt;</code> <code>java.util.Comparator&lt;T&gt;</code> , JDK提供的Comparable ,Comparator都是使用了泛型. 点击<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">了解泛型</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用比较策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    private Comparator comparator = new CatHeightComparator();</span></span><br><span class="line"><span class="comment">//    private Comparator comparator = new CatWeightComparator();</span></span><br><span class="line">    <span class="keyword">private</span> java.util.Comparator&lt;Cat&gt; comparator = <span class="keyword">new</span> CatWeightComparator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用jdk的Comparable接口,Comparator接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparator.compare(<span class="keyword">this</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// 省略get set  toString ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CatWeightComparator.java</p><p><strong>注意:</strong> 这里我们使用JDK为我们提供的Comparator</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatWeightComparator</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Comparator</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cat o1, Cat o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.getWeight() &gt; o2.getWeight()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o1.getWeight() &lt; o2.getWeight()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><p><strong>注意:</strong> 这里使用了JDK为我们提供的排序算法, java.util.Arrays.sort(Object[] a);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat[] arr = &#123;<span class="keyword">new</span> Cat(<span class="number">5</span>, <span class="number">5</span>), <span class="keyword">new</span> Cat(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> Cat(<span class="number">3</span>, <span class="number">3</span>)&#125;;</span><br><span class="line">        java.util.Arrays.sort(arr);</span><br><span class="line">        DataSorter.print(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>策略模式:</strong></p><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><p>GitHub项目地址: <a href="https://github.com/wz-dazhi/designPatterns/tree/master/Strategy/src/com/wz/dp/strategy" target="_blank" rel="noopener">Strategy</a></p><p><strong>转载请注明此处:</strong></p><p><a href="http://hexo.dazhi.info/2018/06/02/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy.html" target="_blank" rel="noopener">http://hexo.dazhi.info/2018/06/02/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy.html</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>java双亲委派机制</title>
    <url>/2020/03/28/java-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<!-- build time:Tue Jun 23 2020 14:19:32 GMT+0800 (China Standard Time) --><h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><p>说到双亲委派肯定跟类加载器ClassLoader是分不开的，下面介绍一下Java中的ClassLoader load Class的一个过程和双亲委派机制，接着自定义自己的ClassLoader。</p><a id="more"></a><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p>类加载器是用来加载Class文件的，当我们写一个java应用程序，翻译成二进制字节码（也就是Class文件格式），然后交给ClassLoader将Class文件load到内存中。</p></li><li><p>在加载一个CLass的过程中，由底向上查找。首先查看自定义类加载器中的缓存有没有加载过，如果没有则在App ClassLoader缓存中有没有加载，如果还没有再一层一层的往上找，最终找到Bootstrap ClassLoader。如果Bootstrap中也没有，那么Bootstrap会尝试的在它自己指定的目录中进行加载。如果在指定目录中没有找到该Class，就会交给它的子加载器Ext，Ext也会在它指定的目录中进行加载。如果也没有，就会一层一层往下找。总的而已，就是一个递归的过程，如果最终还没找到该Class，会抛出ClassNotFoundException。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328124519117.png" alt="类加载器"></p><blockquote><p>JVM是按照按需加载的，采用双亲委派机制。java中ClassLoader都是继承java.lang.ClassLoader抽象类，继承该类的都有自己的父加载器（并非extends继承），因为java.lang.ClassLoader有一个成员变量parent，所以子类都有属于自己的父加载器，表明该加载器的父加载器是谁。（下面通过程序的方式打印）</p><p>Java默认的类加载器：</p><ul><li><p>Bootstrap ClassLoader 启动类加载器：</p><p>由C++实现（Hostpot，不同虚拟机实现不同）。</p><p>负责加载JAVA_HOME/lib下面的核心jar文件，比如：rt.jar、charsets.jar…</p></li><li><p>Extension ClassLoader 扩展类加载器：</p><p>继承ClassLoader抽象类，负责加载JAVA_HOME/lib/ext下面的扩展jar。</p><p>或者由环境变量-Djava.ext.dirs指定的目录。</p></li><li><p>Application ClassLoader</p><p>也是继承ClassLoader抽象类，主要负责加载java.class.path目录下的Class文件，也就是咱们自己的应用程序。</p><p>由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为<strong>系统（System）加载器</strong>。</p></li></ul></blockquote><ul><li><p>每个ClassLoader负责加载的目录，可以通过查看源码的方式进行输出。</p><ol><li>sun.misc.Launcher的源码中可以看到Bootstrap加载的目录</li></ol><p><code>private static String bootClassPath = System.getProperty(&quot;sun.boot.class.path&quot;);</code></p><ol start="2"><li>sun.misc.Launcher$ExtClassLoader 负责加载的目录</li></ol><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328171306879.png" alt="ExtClassLoader加载目录源码"></p><ol start="3"><li>sun.misc.Launcher$AppClassLoader 负责加载的目录</li></ol><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328171204072.png" alt="AppClassLoader加载目录源码"></p><ol start="4"><li><p>接下来可以根据源码中的路径，输出对应的加载目录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"------&gt; BootStrap class path"</span>);</span><br><span class="line">    String bootPath = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line">    System.out.println(bootPath.replaceAll(<span class="string">":"</span>, System.lineSeparator()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------&gt; Ext class path"</span>);</span><br><span class="line">    String extPath = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">    System.out.println(extPath.replaceAll(<span class="string">":"</span>, System.lineSeparator()));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------&gt; App class path"</span>);</span><br><span class="line">    String classPath = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    System.out.println(classPath.replaceAll(<span class="string">":"</span>, System.lineSeparator()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328171623842.png" alt="输出各个ClassLoader加载的目录"></p></li><li><p>打印一个类的加载器。下面输出为null的属于BootStrap ClassLoader，由于Bootstrap ClassLoader启动类加载器是由JVM（C++）实现的，在java中并没有对应的Class对象，所以打印null。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印该类的加载器</span></span><br><span class="line">    System.out.println(Test1<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getClass</span>())</span>;</span><br><span class="line">    <span class="comment">// 打印该类的加载器的父加载器</span></span><br><span class="line">    System.out.println(Test1<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getClass</span>())</span>;</span><br><span class="line">    <span class="comment">// 打印该类的加载器的父加载器的父加载器</span></span><br><span class="line">    System.out.println(Test1<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getClass</span>().<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">    <span class="comment">// 打印系统类加载器</span></span><br><span class="line">    System.out.println(ClassLoader.getSystemClassLoader().getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328132525596.png" alt="打印类加载器"></p></li><li><p>一个Class文件的详细加载过程</p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328140000023.png" alt="Class详细加载"></p></li></ul><h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><ol><li><p>准备class文件</p><p>在/Users/wangzhi/test/com/test 目录下新建T.java 文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------&gt; t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行编译 <code>javac T.java</code></p><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328163410948.png" alt="准备class文件"></p></li><li><p>自定义ClassLoader，方便演示，简单重写findClass方法。</p><ol><li>自定义类加载器继承ClassLoader</li><li>重写findClass方法<ul><li>读取class文件</li><li>定义class对象</li><li>返回Class对象</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String classPath = <span class="string">"file:///Users/wangzhi/test/"</span> + name.replace(<span class="string">"."</span>, <span class="string">"/"</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] cLassBytes;</span><br><span class="line">        Path path;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            path = Paths.get(<span class="keyword">new</span> URI(classPath));</span><br><span class="line">            cLassBytes = Files.readAllBytes(path);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, cLassBytes, <span class="number">0</span>, cLassBytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | URISyntaxException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(classPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        String className = <span class="string">"com.test.T"</span>;</span><br><span class="line">        MyClassLoader loader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class&lt;?&gt; clazz = loader.findClass(className);</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">        Object t = clazz.newInstance();</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"t"</span>);</span><br><span class="line">        method.invoke(t);</span><br><span class="line">        System.out.println(t.getClass().getClassLoader());</span><br><span class="line">        System.out.println(t.getClass().getClassLoader().getParent().getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>输出如下：<ul><li>获取T Class对象</li><li>创建T的一个实例对象</li><li>调用t方法</li><li>打印T Class类加载器</li><li>打印T Class类加载器的父加载器（也可以指定父加载器）</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/wz-dazhi/pic@master/blog/jvm/image-20200328164600598.png" alt="自定义ClassLoader输出"></p></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>大多数情况下java中默认的ClassLoader足够我们使用，自定义加载器是为了更好的扩展。</p><p>比如：网络加载，数据库读取加载，对字节码做加解密处理。</p><p>Tomcat、Spring等框架都有自己的ClassLoader</p></li></ul><ul><li><p>双亲委派机制其实是为了防止类重复加载的一个过程，最重要的一点是出于安全考虑。如果我们自己定义一个java.lang.String ，ClassLoader进行加载的时候，会检查类的权限类名是否以java.开头。如果是会报出异常</p><p><code>Exception in thread &quot;main&quot; java.lang.SecurityException: **Prohibited package name: java.lang**</code></p></li></ul><ul><li>双亲委派模式是建立的ClassLoader中的loadClass方法，在上面的实验中只是简单重写了findClass方法。如果想要打破双亲委派可以重写loadClass方法，ThreadContextClassLoader可以实现基础类调用实现类代码，通过thread.setContextClassLoader指定，Tomcat、热部署等都是属于打破了双亲委派机制。</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
